## Работа с методами контроллеров в Next.js

Next.js, помимо рендеринга страниц, предоставляет удобный механизм для обработки HTTP-запросов на стороне сервера – **API-маршруты (API routes)**. Они позволяют создавать бессерверные функции (serverless functions), которые обрабатывают запросы и возвращают данные. API-маршруты определяются как обычные JavaScript-файлы в директории `pages/api` вашего проекта.

Ключевым элементом API-маршрутов являются **методы контроллеров**.  Это функции, которые обрабатывают конкретный HTTP-метод (GET, POST, PUT, DELETE и др.) для данного маршрута. 

### Создание простого API-маршрута

Давайте создадим простой API-маршрут, который будет возвращать список продуктов.

1. Создайте файл `pages/api/products.js`
2. Добавьте следующий код:

```javascript
// pages/api/products.js

export default function handler(req, res) {
  // Пример данных
  const products = [
    { id: 1, name: 'Футболка', price: 1000 },
    { id: 2, name: 'Джинсы', price: 2500 },
    { id: 3, name: 'Кеды', price: 3000 },
  ];

  res.status(200).json(products);
}
```

В этом примере:
- `handler` - это функция, которая будет вызываться при каждом запросе к этому API-маршруту.
- `req` (request) - объект запроса, содержащий информацию о HTTP-запросе.
- `res` (response) - объект ответа, позволяющий управлять ответом сервера.
- `res.status(200).json(products)` - устанавливает код ответа 200 (OK) и возвращает данные в формате JSON.

Теперь, при обращении к `http://localhost:3000/api/products`, вы получите список продуктов в формате JSON.

### Работа с разными HTTP-методами

Часто API-маршруты должны обрабатывать разные HTTP-методы. Next.js предоставляет простой способ сделать это:

```javascript
// pages/api/products/[id].js

export default function handler(req, res) {
  const { id } = req.query; // Получаем id из URL

  switch (req.method) {
    case 'GET':
      // Получение продукта по id
      const product = { id: id, name: 'Футболка', price: 1000 };
      res.status(200).json(product);
      break;
    case 'PUT':
      // Обновление продукта
      res.status(200).json({ message: `Продукт ${id} обновлен` });
      break;
    case 'DELETE':
      // Удаление продукта
      res.status(200).json({ message: `Продукт ${id} удален` });
      break;
    default:
      res.status(405).end(); // Метод не разрешен
  }
}
```

В этом примере:

- `[id].js` – динамический маршрут, позволяющий получать доступ к `id` из URL.
-  `req.query` – объект, содержащий параметры запроса из URL.
-  `switch (req.method)` – блок, разделяющий обработку запроса в зависимости от HTTP-метода.

### Обработка ошибок

Обработка ошибок важна для любого API. В Next.js вы можете использовать `try...catch` и объект `res` для обработки ошибок:

```javascript
// pages/api/products/[id].js

export default function handler(req, res) {
  try {
    // ... логика обработки запроса ...
  } catch (error) {
    console.error(error); // Логируем ошибку
    res.status(500).json({ message: 'Ошибка сервера' });
  }
}
```

Этот код перехватывает любые ошибки, возникшие во время обработки запроса, логирует их и возвращает клиенту ответ с кодом 500 (Internal Server Error).

###  Заключение

Методы контроллеров являются основой для создания API-маршрутов в Next.js. Используя их, вы можете создавать гибкие и функциональные API для вашего приложения. В следующих разделах руководства мы подробнее рассмотрим обработку данных, валидацию, аутентификацию и другие важные аспекты разработки API. 
