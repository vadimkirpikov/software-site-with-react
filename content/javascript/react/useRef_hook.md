## Использование useRef для работы с DOM и сохранения значений

В React работа с DOM напрямую обычно не приветствуется. Вместо этого рекомендуется использовать декларативный подход, при котором вы описываете, как должен выглядеть UI в зависимости от состояния, а React сам заботится об обновлении DOM. 

Однако, бывают ситуации, когда требуется прямое взаимодействие с DOM. Например, для интеграции с сторонними библиотеками, для работы с фокусом или для реализации кастомных анимаций. В таких случаях на помощь приходит хук `useRef`.

### Что такое useRef?

`useRef` — это хук React, который позволяет создавать "ссылку". Ссылка — это объект, содержащий свойство `current`. Вы можете записать в `current` любое значение, и оно сохранится между рендерами компонента.

```javascript
import React, { useRef } from 'react';

function MyComponent() {
  const myRef = useRef(null);

  return (
    <div>
      <input type="text" ref={myRef} />
    </div>
  );
}
```

В этом примере мы создаем ссылку `myRef` с помощью `useRef(null)`. Затем мы передаем эту ссылку в атрибут `ref` элемента `input`. Теперь мы можем получить доступ к этому элементу `input` через свойство `current` ссылки `myRef`.

### Работа с DOM через useRef

Давайте рассмотрим пример, как использовать `useRef` для фокусировки на поле ввода при загрузке компонента:

```javascript
import React, { useRef, useEffect } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Фокусируемся на поле ввода после монтирования компонента
    inputRef.current.focus();
  }, []);

  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
}
```

В этом примере:

1. Мы создаем ссылку `inputRef` с помощью `useRef(null)`.
2. Передаем эту ссылку в атрибут `ref` элемента `input`.
3. Внутри хука `useEffect`, который срабатывает после монтирования компонента, мы вызываем метод `focus()` у элемента `input`, доступ к которому получаем через `inputRef.current`.

### Сохранение значений между рендерами

Помимо работы с DOM, `useRef` также полезен для хранения значений между рендерами компонента. В отличие от состояния, изменение значения в `current` не вызывает перерендер компонента.

Рассмотрим пример счетчика, где мы храним количество нажатий на кнопку во внешней переменной:

```javascript
import React, { useRef, useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  const rendersCount = useRef(0);

  const handleClick = () => {
    setCount(count + 1);
    rendersCount.current++; 
  };

  return (
    <div>
      <p>Количество нажатий: {count}</p>
      <p>Количество рендеров: {rendersCount.current}</p>
      <button onClick={handleClick}>Нажми меня</button>
    </div>
  );
}
```

В этом примере:

1. Мы создаем ссылку `rendersCount` с помощью `useRef(0)`.
2. Внутри обработчика `handleClick` мы увеличиваем значение `rendersCount.current` при каждом нажатии на кнопку.
3. Обратите внимание, что изменение `rendersCount.current` не приводит к перерендеру компонента, поэтому значение счетчика рендеров увеличивается только при фактическом рендере.

### Заключение

`useRef` – это мощный инструмент React, который позволяет работать с DOM напрямую и хранить значения между рендерами компонента. Используйте его с осторожностью, помня, что прямое манипулирование DOM может нарушить принципы работы React и привести к неожиданному поведению приложения. 
