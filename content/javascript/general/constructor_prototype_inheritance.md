## Наследование прототипов в Javascript: создаем иерархии объектов

В JavaScript наследование предоставляет мощный механизм для повторного использования кода и построения сложных взаимосвязей между объектами.  В отличие от классического наследования, где классы выступают чертежами для создания объектов, JavaScript использует **прототипное наследование**. 

В основе прототипного наследования лежит концепция **прототипов**. Каждый объект в JavaScript обладает скрытым свойством `__proto__` (или `prototype`, если речь идет о функции-конструкторе), которое ссылается на другой объект – его прототип. Когда мы пытаемся получить доступ к свойству объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта, затем в прототипе прототипа и так далее, образуя **цепочку прототипов**.

### Конструкторы и прототипы

**Конструкторы** – это специальные функции, которые используются для создания новых объектов. Каждый конструктор автоматически получает свойство `prototype`, указывающее на объект-прототип для всех объектов, создаваемых этим конструктором. 

Рассмотрим пример:

```javascript
function Animal(name) {
  this.name = name;
}

// Добавляем метод в прототип Animal
Animal.prototype.speak = function() {
  console.log(`${this.name} издает звук.`);
};

let cat = new Animal('Мурка');
cat.speak(); // Вывод: Мурка издает звук.
```

В этом примере `Animal` – это конструктор, который принимает имя животного и присваивает его свойству `name` создаваемого объекта.  Мы добавляем метод `speak` в `Animal.prototype`, делая его доступным для всех объектов, созданных через конструктор `Animal`.

### Наследование прототипов конструкторов

Наследование прототипов позволяет создавать новые конструкторы, наследующие свойства и методы от существующих. Для этого мы выполняем следующие шаги:

1. **Создаем новый конструктор.**
2. **Устанавливаем прототип нового конструктора на новый объект, созданный с помощью конструктора родительского прототипа.** 
3. **Устанавливаем свойство `constructor` нового прототипа на сам новый конструктор.**

Рассмотрим пример наследования от нашего конструктора `Animal`:

```javascript
function Cat(name, breed) {
  // Вызываем конструктор родителя
  Animal.call(this, name); 
  this.breed = breed;
}

// Устанавливаем прототип Cat на новый объект Animal
Cat.prototype = Object.create(Animal.prototype);

// Восстанавливаем свойство constructor
Cat.prototype.constructor = Cat; 

// Добавляем метод в прототип Cat
Cat.prototype.meow = function() {
  console.log(`${this.name} мяукнул.`);
};

let myCat = new Cat('Барсик', 'Сибирская');
myCat.speak(); // Вывод: Барсик издает звук. (унаследовано от Animal)
myCat.meow();  // Вывод: Барсик мяукнул.
```

В этом примере мы создаем конструктор `Cat`, который наследует от `Animal`. Обратите внимание на следующие моменты:

* `Animal.call(this, name)` - вызываем конструктор `Animal` в контексте нового объекта `Cat`, чтобы инициализировать унаследованные свойства.
* `Object.create(Animal.prototype)` - создает новый объект, который наследует от прототипа `Animal` и устанавливается как прототип для `Cat`.
* `Cat.prototype.constructor = Cat` - восстанавливаем свойство `constructor` после изменения прототипа.

### Проверка наследования

Для проверки принадлежности объекта к определенному прототипу мы можем использовать оператор `instanceof`:

```javascript
console.log(myCat instanceof Cat); // true
console.log(myCat instanceof Animal); // true
```

### Преимущества наследования прототипов

* **Эффективное повторное использование кода:**  Изменения в прототипе автоматически отражаются на всех объектах, наследующих от него.
* **Гибкость:**  Прототипы можно изменять динамически, добавляя новые свойства и методы.
* **Понятность:**  Прототипное наследование может быть более интуитивно понятным, чем классическое наследование, особенно для начинающих разработчиков.

### Заключение

Наследование прототипов - это мощный инструмент, который позволяет создавать гибкие и эффективные иерархии объектов в JavaScript.  Понимание принципов прототипного наследования -  ключ к написанию чистого, поддерживаемого и масштабируемого кода. 
