## Переопределение функций в JavaScript

В JavaScript функции являются объектами первого класса, что наделяет их рядом интересных особенностей. Одной из таких особенностей является возможность **переопределения функций**. Переопределение функции подразумевает под собой объявление новой функции с тем же именем, что и у существующей. 

### Основы переопределения

Рассмотрим простой пример:

```javascript
function greet(name) {
    console.log("Привет, " + name + "!");
}

greet("Иван"); // Вывод: Привет, Иван!

function greet(name) {
    console.log("Здравствуйте, " + name + "!");
}

greet("Иван"); // Вывод: Здравствуйте, Иван!
```

В этом примере мы сначала определили функцию `greet`, которая выводит простое приветствие. Затем мы **переопределили** функцию `greet`, добавив более формальное приветствие. При повторном вызове функции `greet` используется уже **новая реализация**. 

Важно понимать, что JavaScript не создает несколько копий функции с одним и тем же именем. При переопределении происходит **замена** старой реализации на новую.

### Переопределение и область видимости

Переопределение функции зависит от **области видимости**.  

* **Глобальная область видимости:** Если функция определена в глобальной области видимости, то ее переопределение повлияет на все участки кода, где эта функция используется. 
* **Локальная область видимости:** Если функция определена внутри другой функции (в локальной области видимости), то ее переопределение действует только **внутри этой функции**. 

```javascript
function outerFunction() {
    function innerFunction() {
        console.log("Вызов внутренней функции");
    }

    innerFunction(); // Вызов: Вызов внутренней функции

    function innerFunction() {
        console.log("Новая реализация внутренней функции");
    }

    innerFunction(); // Вызов: Новая реализация внутренней функции
}

outerFunction();

innerFunction(); // Ошибка! Функция innerFunction не определена 
```

В данном примере функция `innerFunction` переопределяется **только внутри функции `outerFunction`**. За пределами `outerFunction` исходная реализация `innerFunction` недоступна, что приводит к ошибке.

### Практическое применение

Переопределение функций может быть полезным инструментом при разработке на JavaScript. Рассмотрим несколько примеров практического применения:

#### 1. Добавление функциональности

Представим, что у нас есть функция `calculatePrice`, которая рассчитывает стоимость товара без учета скидки. Мы можем переопределить эту функцию, добавив логику для расчета скидки:

```javascript
function calculatePrice(price) {
    return price; 
}

function calculatePrice(price, discount = 0) { // discount - необязательный параметр со значением по умолчанию 0
    let finalPrice = price * (1 - discount / 100);
    return finalPrice;
}

console.log(calculatePrice(100)); // Вывод: 100
console.log(calculatePrice(100, 10)); // Вывод: 90
```

В данном примере мы переопределили функцию `calculatePrice`, добавив параметр `discount`.  Теперь функция может принимать скидку в качестве аргумента и возвращать цену со скидкой.

#### 2. Мокирование функций при тестировании

Переопределение функций также широко используется при написании тестов. **Мокирование** функции - это замена реальной функции на ее имитацию для изоляции тестируемого кода.

```javascript
function fetchDataFromAPI(url) {
    // Код для получения данных с API
}

function processData(data) {
    // Код для обработки данных
}

// Тестирование функции processData
function fetchDataFromAPIMock(url) { 
    return {
        status: "ok",
        data: [1, 2, 3]
    };
}

fetchDataFromAPI = fetchDataFromAPIMock; // Переопределение для теста

let processedData = processData(fetchDataFromAPI()); // Используем мок-функцию

console.log(processedData); 
```

В этом примере мы переопределили функцию `fetchDataFromAPI` на мок-функцию `fetchDataFromAPIMock`, которая возвращает заранее подготовленные данные. Это позволяет нам протестировать функцию `processData` независимо от реального API. 

### Заключение

Переопределение функций в JavaScript - это мощный инструмент, который может быть полезен в различных сценариях, от добавления новой функциональности до упрощения тестирования. Понимание принципов переопределения и области видимости поможет вам писать более гибкий и maintainable код.
