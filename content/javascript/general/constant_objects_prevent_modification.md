## Запрет изменения объектов в JavaScript

JavaScript предоставляет разработчикам гибкость в работе с объектами, позволяя динамически изменять их свойства.  Однако, бывают ситуации, когда необходимо гарантировать неизменность объекта, чтобы предотвратить случайные или нежелательные модификации. 

В JavaScript не существует способа сделать объект полностью неизменяемым в прямом смысле этого слова. Однако, мы можем использовать ряд подходов, чтобы ограничить возможности изменения объекта и сделать его "константным" на практике.

### Object.freeze()

Метод `Object.freeze()` позволяет "заморозить" объект, предотвращая:

* Добавление новых свойств
* Удаление существующих свойств
* Изменение значений свойств
* Изменение атрибутов свойств (writable, configurable, enumerable)

Важно отметить, что `Object.freeze()` выполняет поверхностное замораживание. Это означает, что если объект содержит вложенные объекты, то они не будут автоматически заморожены. 

**Пример:**

```javascript
const user = {
  name: "John",
  age: 30,
  address: {
    city: "New York",
  },
};

Object.freeze(user);

// Попытки изменения вызовут ошибку в строгом режиме
user.name = "Jane"; // Ошибка!
delete user.age;    // Ошибка!
user.address.city = "Los Angeles"; // Работает! Вложенный объект не заморожен
```

**Проверка заморозки:**

Для проверки, заморожен ли объект, можно воспользоваться методом `Object.isFrozen()`:

```javascript
console.log(Object.isFrozen(user)); // true
console.log(Object.isFrozen(user.address)); // false
```

### Глубокое замораживание

Для реализации глубокого замораживания, где все уровни вложенности также становятся неизменяемыми, необходимо рекурсивно применить `Object.freeze()` ко всем вложенным объектам.

**Пример функции для глубокого замораживания:**

```javascript
function deepFreeze(obj) {
  // Замораживаем текущий объект
  Object.freeze(obj);

  // Рекурсивно замораживаем все вложенные объекты
  for (const key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  }

  return obj;
}

const user = {
  name: "John",
  age: 30,
  address: {
    city: "New York",
  },
};

deepFreeze(user);

user.address.city = "Los Angeles"; // Ошибка! Глубокая заморозка
```

### Object.seal() и Object.preventExtensions()

В дополнение к `Object.freeze()`, JavaScript предоставляет и другие методы для управления расширяемостью и изменяемостью объектов:

* **Object.seal()**: запрещает добавление и удаление свойств, но позволяет изменять значения существующих свойств.
* **Object.preventExtensions()**: запрещает только добавление новых свойств.

Аналогично `Object.freeze()`, эти методы также выполняют поверхностные операции.

### Использование констант и примитивных типов

Важно помнить, что присваивание объекта константе с помощью `const` не делает сам объект неизменяемым. 

```javascript
const user = { name: "John" };
user.name = "Jane"; // Работает!
```

Ключевое слово `const` предотвращает только переприсваивание переменной, но не защищает сам объект от изменений.

Для обеспечения неизменяемости, используйте `Object.freeze()`, `Object.seal()` или `Object.preventExtensions()` в сочетании с `const`.

**Использование примитивных типов:**

Примитивные типы данных (string, number, boolean, null, undefined, symbol) в JavaScript неизменяемы по умолчанию. 

```javascript
const name = "John";
name = "Jane"; // Ошибка! Нельзя изменить примитивное значение
```

### Выбор правильного подхода

Выбор метода для предотвращения изменений объекта зависит от конкретных требований:

* **Object.freeze()**: максимальная защита, подходит для данных, которые не должны изменяться.
* **Object.seal()**:  ограничивает возможности изменения, подходит для объектов, структура которых должна оставаться неизменной.
* **Object.preventExtensions()**:  предотвращает расширение объекта, подходит для случаев, когда объект не должен получать новые свойства.

### Заключение

В JavaScript нет встроенной неизменяемости объектов, но  `Object.freeze()`, `Object.seal()` и `Object.preventExtensions()`, а также использование констант и примитивных типов, позволяют контролировать  изменяемость и создавать более предсказуемый и безопасный код. 

Понимание особенностей работы с объектами и применение соответствующих методов защиты от нежелательных модификаций является важной частью разработки качественных и надежных JavaScript-приложений.
