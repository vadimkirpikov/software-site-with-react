## Классы

В JavaScript классы являются **синтаксическим сахаром** над уже существующим прототипным наследованием. 
Они предоставляют более **четкую и удобную** структуру для определения объектов и их поведения.

### Определение класса

Для определения класса используется ключевое слово `class`, за которым следует имя класса и блок кода в фигурных скобках:

```javascript
class Car {
  // Тело класса
}
```

Внутри блока кода мы определяем **свойства** и **методы** класса.

### Конструктор

**Конструктор** — это специальный метод, который вызывается при создании нового экземпляра класса (объекта). 
Он используется для инициализации свойств объекта. 

Конструктор определяется с помощью ключевого слова `constructor`:

```javascript
class Car {
  constructor(brand, model, year) {
    this.brand = brand;
    this.model = model;
    this.year = year;
  }
}
```

В этом примере конструктор принимает три аргумента (`brand`, `model`, `year`) и присваивает их значения соответствующим свойствам объекта (`this.brand`, `this.model`, `this.year`).

### Создание экземпляра класса

Для создания экземпляра класса используется ключевое слово `new`, за которым следует имя класса и круглые скобки:

```javascript
const myCar = new Car('Ford', 'Mustang', 1967);
```

Этот код создаст новый объект `myCar` класса `Car` с указанными значениями свойств.

### Методы класса

**Методы класса** — это функции, которые определяют поведение объектов класса. 
Они определяются внутри блока кода класса:

```javascript
class Car {
  // ... конструктор ...

  getCarInfo() {
    return `${this.year} ${this.brand} ${this.model}`;
  }
}
```

В этом примере определен метод `getCarInfo()`, который возвращает строку с информацией об автомобиле.

Для вызова метода используется точечная нотация:

```javascript
console.log(myCar.getCarInfo()); // Вывод: 1967 Ford Mustang
```

### Наследование

**Наследование** позволяет создавать новые классы на основе существующих, наследуя их свойства и методы. 
Для наследования используется ключевое слово `extends`:

```javascript
class ElectricCar extends Car {
  constructor(brand, model, year, batteryCapacity) {
    super(brand, model, year); // Вызов конструктора родительского класса
    this.batteryCapacity = batteryCapacity;
  }

  getCarInfo() {
    return `${super.getCarInfo()}, Battery: ${this.batteryCapacity}kWh`;
  }
}
```

В этом примере класс `ElectricCar` наследуется от класса `Car`. 
В конструкторе `ElectricCar` вызывается конструктор родительского класса с помощью `super()`, 
а также определяется новое свойство `batteryCapacity`. Метод `getCarInfo()` переопределен для добавления 
информации о емкости аккумулятора.

Теперь можно создавать экземпляры класса `ElectricCar`:

```javascript
const myElectricCar = new ElectricCar('Tesla', 'Model S', 2023, 100);
console.log(myElectricCar.getCarInfo()); // Вывод: 2023 Tesla Model S, Battery: 100kWh
```

### Статические методы

**Статические методы** — это методы, которые связаны с самим классом, а не с его экземплярами. 
Они определяются с помощью ключевого слова `static`:

```javascript
class Car {
  // ...

  static honk() {
    console.log('Beep beep!');
  }
}
```

Статические методы вызываются с помощью имени класса:

```javascript
Car.honk(); // Вывод: Beep beep!
```

### Геттеры и сеттеры

**Геттеры** и **сеттеры** — это специальные методы, которые позволяют контролировать доступ к свойствам объекта.

**Геттер** используется для получения значения свойства, а **сеттер** — для его установки.

```javascript
class Car {
  // ...

  get year() {
    return this._year;
  }

  set year(value) {
    if (value > new Date().getFullYear()) {
      throw new Error('Год выпуска не может быть больше текущего года');
    }
    this._year = value;
  }
}
```

В этом примере геттер `year` возвращает значение свойства `_year`. 
Сеттер `year` проверяет, 
что передаваемое значение не больше текущего года, и только после этого устанавливает его.

Обратите внимание, что для хранения значения свойства используется 
внутреннее свойство `_year`, 
так как прямое обращение к `this.year` 
привело бы к рекурсивному вызову геттера.

Использование геттеров и сеттеров позволяет 
добавить логику валидации 
и обработки данных при 
получении и установке значений свойств объекта.

### Приватные поля класса

**Приватные поля класса** - это поля, 
которые доступны только 
внутри самого класса. 
Для объявления приватного 
поля используется префикс `#`.

```javascript
class Car {
  #engineType = 'Gasoline';

  getEngineType() {
    return this.#engineType;
  }
}

const myCar = new Car();
console.log(myCar.getEngineType()); // Вывод: 'Gasoline'
console.log(myCar.#engineType); // Ошибка: SyntaxError
```

В этом примере поле `#engineType` 
является приватным 
и доступно только внутри класса `Car`. 
Попытка доступа к нему 
извне приведет к ошибке.

### Вывод

Классы в JavaScript предоставляют удобный 
и мощный инструмент 
для создания 
и управления объектами. 
Они делают код 
более структурированным, 
читаемым и 
легким в поддержке. 
Использование классов 
рекомендуется 
в большинстве 
случаев при разработке 
на JavaScript, 
особенно в 
проектах 
среднего 
и большого размера. 
