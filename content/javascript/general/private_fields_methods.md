## Приватные поля и методы в JavaScript

В JavaScript, традиционно, не было прямого способа объявления приватных свойств и методов класса. Все члены класса были публичными, что могло приводить к непреднамеренному доступу и модификации внутренних данных объекта.  

Однако, с появлением стандарта ECMAScript 2015 (ES6), были представлены новые подходы к реализации приватности в JavaScript. Давайте рассмотрим эти подходы, а также их особенности и ограничения.

### Соглашения об именовании 

До введения новых стандартов, разработчики использовали соглашения об именовании для обозначения "приватных" свойств и методов. Обычно, имя такого члена класса предваряли символом подчеркивания `_`.

```javascript
class Product {
  constructor(name, price) {
    this.name = name; 
    this._price = price; // _price считается "приватным" по соглашению
  }

  getPriceWithDiscount(discount) {
    return this._price * (1 - discount);
  }
}

const product = new Product('Телефон', 1000);
console.log(product.name); // Доступ к публичному свойству
console.log(product._price); // Доступ к "приватному" свойству все еще возможен
```

**Важно:** Такой подход **не гарантирует** настоящей приватности.  Символ `_` всего лишь  маркирует свойство как "приватное" по соглашению, но технически не ограничивает доступ к нему.

### Приватные поля с помощью `#`

Стандарт ECMAScript 2022 (ES11) представил новый синтаксис для объявления **настоящих** приватных полей класса - с использованием символа `#`.

```javascript
class Product {
  #price; // Приватное поле

  constructor(name, price) {
    this.name = name; 
    this.#price = price; 
  }

  getPriceWithDiscount(discount) {
    return this.#price * (1 - discount);
  }
}

const product = new Product('Телефон', 1000);
console.log(product.name); // Доступ к публичному свойству
console.log(product.#price); // Ошибка! Нет доступа к приватному полю извне
```

**Преимущества приватных полей:**

* **Настоящая инкапсуляция:** Доступ к приватным полям ограничен только методами того же класса.
* **Защита от случайного доступа:** Исключены случайные изменения приватных данных извне.
* **Повышение надежности кода:**  Код становится более предсказуемым и простым в поддержке.

**Важно:**

* Приватные поля должны быть объявлены **внутри тела класса** до их использования.
* Приватные поля **недоступны** для доступа через `this` внутри конструктора до его вызова (например, в деструктуризации).

### Приватные методы

На данный момент, стандарт JavaScript **не поддерживает** приватные методы напрямую. Однако, можно использовать приватные поля для хранения ссылок на функции, эмулируя таким образом приватность методов.

```javascript
class Product {
  #price;
  #calculateDiscount = (discount) => this.#price * discount; // "Приватный" метод

  constructor(name, price) {
    this.name = name;
    this.#price = price; 
  }

  getPriceWithDiscount(discount) {
    return this.#price - this.#calculateDiscount(discount); 
  }
}

const product = new Product('Телефон', 1000);
console.log(product.#calculateDiscount); // Ошибка! Нет доступа к "приватному" методу
```

**Важно:** Этот подход предоставляет ограниченную приватность, так как ссылка на функцию хранится в приватном поле, к которому все еще можно получить доступ из методов того же класса.

### Выводы

Использование приватных полей и методов способствует созданию более надежного, модульного и поддерживаемого кода.  Новые возможности JavaScript в области инкапсуляции данных  -  это важный шаг в развитии языка.
