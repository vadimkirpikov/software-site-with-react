## Наследование классов в PHP

Наследование - один из фундаментальных принципов объектно-ориентированного программирования (ООП), позволяющий создавать новые классы на основе существующих. Новый класс, называемый **классом-наследником**, наследует все свойства и методы **родительского класса**, также известного как **базовый** или **суперкласс**,  и может расширять его функциональность, добавляя новые свойства и методы или переопределяя существующие.

### Объявление класса-наследника

Для создания класса-наследника в PHP используется ключевое слово `extends`:

```php
class ParentClass {
    // Свойства и методы родительского класса
}

class ChildClass extends ParentClass {
    // Свойства и методы класса-наследника
}
```

В данном примере `ChildClass` наследует все свойства и методы `ParentClass`. 

### Доступ к наследуемым членам класса

Класс-наследник имеет доступ ко всем **неприватным** свойствам и методам родительского класса.  Для доступа к наследуемым членам используется ключевое слово `parent` или псевдопеременная `$this`:

```php
class Vehicle {
    public $brand;

    public function __construct($brand) {
        $this->brand = $brand;
    }

    public function getBrand() {
        return $this->brand;
    }
}

class Car extends Vehicle {
    public function honk() {
        echo "{$this->getBrand()} сигналит: Бип-бип!<br>"; 
    }
}

$myCar = new Car("Toyota");
$myCar->honk(); // Вывод: Toyota сигналит: Бип-бип!
```

В примере `Car` наследует свойство `$brand` и метод `getBrand()` от `Vehicle`. В методе `honk()` мы обращаемся к методу родительского класса через `$this->getBrand()`. 

### Переопределение методов

Класс-наследник может переопределить методы родительского класса, предоставляя свою реализацию.  

```php
class Animal {
    public function makeSound() {
        echo "Животное издаёт звук<br>";
    }
}

class Dog extends Animal {
    public function makeSound() {
        echo "Собака лает: Гав-гав!<br>"; 
    }
}

$animal = new Animal();
$animal->makeSound(); // Вывод: Животное издаёт звук

$dog = new Dog();
$dog->makeSound(); // Вывод: Собака лает: Гав-гав!
```

В этом случае, при вызове метода `makeSound()` у объекта класса `Dog`, будет выполняться переопределенный метод, а не метод родительского класса.

### Ключевое слово "final"

Ключевое слово `final`  может использоваться для предотвращения наследования класса или переопределения метода. 

**final класс:**

```php
final class MyClass {
    // ...
}

// Ошибка: Класс "YourClass" не может быть наследником финального класса "MyClass"
class YourClass extends MyClass { 
    // ...
}
```

**final метод:**

```php
class MyClass {
    final public function myMethod() {
        // ...
    }
}

class YourClass extends MyClass {
    // Ошибка: Нельзя переопределить финальный метод "MyClass::myMethod()" 
    public function myMethod() { 
        // ...
    }
}
```

### Абстрактные классы и методы

**Абстрактный класс** - это класс, который не может быть создан напрямую. Он объявляется с помощью ключевого слова `abstract` и используется как базовый класс для других классов. Абстрактный класс может содержать **абстрактные методы**, которые не имеют реализации и должны быть определены в классах-наследниках.

```php
abstract class Shape {
    abstract public function calculateArea(): float;
}

class Rectangle extends Shape {
    private $width;
    private $height;

    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }

    public function calculateArea(): float {
        return $this->width * $this->height;
    }
}

$rectangle = new Rectangle(5, 10);
echo "Площадь прямоугольника: " . $rectangle->calculateArea(); // Вывод: Площадь прямоугольника: 50
```

В этом примере `Shape` -  абстрактный класс с абстрактным методом `calculateArea()`. Класс `Rectangle` наследует `Shape` и обязан реализовать метод `calculateArea()`.

### Преимущества наследования

* **Повторное использование кода:** Наследование позволяет избежать дублирования кода, так как классы-наследники автоматически получают функциональность родительских классов.
* **Расширяемость:**  Наследование позволяет легко расширять функциональность существующих классов, не изменяя их исходный код.
* **Полиморфизм:** Наследование является основой для полиморфизма, который позволяет использовать объекты разных классов через единый интерфейс.

### Рекомендации по использованию наследования

* Используйте наследование, когда нужно  моделировать отношения "является" между классами (например, "автомобиль" является "транспортным средством").
* Избегайте наследования, если  отношения "является"  не очевидны или  нужно просто использовать функциональность другого класса (в таком случае лучше рассмотреть композицию).
* Не злоупотребляйте наследованием -  слишком глубокие иерархии классов могут усложнить код и сделать его  менее  понятным.

### Заключение

Наследование -  мощный инструмент ООП, который позволяет создавать гибкие, расширяемые и легко поддерживаемые приложения. Правильное использование наследования может существенно улучшить качество вашего кода. 
