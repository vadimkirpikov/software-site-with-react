## Регулярные выражения в PHP

Регулярные выражения — мощный инструмент для работы с текстом, позволяющий находить и изменять строки по заданным шаблонам. PHP предоставляет богатый набор функций для работы с регулярными выражениями, используя библиотеку PCRE (Perl Compatible Regular Expressions).

### Синтаксис регулярных выражений

Шаблон регулярного выражения — это строка, определяющая набор правил для поиска. Рассмотрим основные элементы синтаксиса:

| Символ | Описание                    | Пример      |
| :----- | :----------------------------- | :----------- |
| .      | Любой символ, кроме переноса строки | `a.c`  |
| *      | Ноль или более повторений предыдущего символа/группы | `ab*c` |
| +      | Одно или более повторений предыдущего символа/группы | `ab+c` |
| ?      | Ноль или одно вхождение предыдущего символа/группы | `ab?c` |
| {n}    | Ровно n повторений предыдущего символа/группы | `ab{2}c`|
| {n,}   | n или более повторений предыдущего символа/группы | `ab{2,}c`|
| {n,m}  | От n до m повторений предыдущего символа/группы | `ab{2,4}c`|
| ^      | Начало строки                 | `^abc` |
| $      | Конец строки                 | `abc$` |
| []     | Набор символов               | `[abc]` |
| [^]    | Любой символ, кроме указанных в наборе | `[^abc]`|
| -      | Диапазон символов в наборе   | `[a-z]` |
| \      | Экранирующий символ          | `\.` |
| \|     | Логическое ИЛИ                | `a\|b` |
| ()     | Группа символов              | `(ab)` |

### Функции для работы с регулярными выражениями

PHP предлагает несколько функций для работы с регулярными выражениями:

* **`preg_match(string $pattern, string $subject, array &$matches = null, int $flags = 0, int $offset = 0): int|false`** - ищет совпадение шаблона `$pattern` в строке `$subject`. Возвращает количество найденных совпадений (0 или 1) или `false` в случае ошибки. Массив `$matches` содержит найденные совпадения.

```php
$string = "My phone number is 123-456-7890.";
$pattern = "/\d{3}-\d{3}-\d{4}/"; // шаблон для поиска номера телефона

if (preg_match($pattern, $string, $matches)) {
    echo "Найден номер телефона: " . $matches[0]; // выведет "123-456-7890"
}
```

* **`preg_match_all(string $pattern, string $subject, array &$matches = null, int $flags = PREG_PATTERN_ORDER, int $offset = 0): int|false`** - находит все совпадения шаблона `$pattern` в строке `$subject`. Возвращает количество найденных совпадений или `false` в случае ошибки. Массив `$matches` содержит все найденные совпадения.

```php
$string = "Apples are red, bananas are yellow.";
$pattern = "/\b[a-z]+\b/i"; // шаблон для поиска слов

if (preg_match_all($pattern, $string, $matches)) {
    print_r($matches[0]); // выведет массив с найденными словами: ["Apples", "are", "red", "bananas", "are", "yellow"]
}
```

* **`preg_replace(string|array $pattern, string|array $replacement, string|array $subject, int $limit = -1, int &$count = null): string|array|null`** - заменяет все совпадения шаблона `$pattern` в строке `$subject` на строку `$replacement`. 

```php
$string = "This is some text.";
$pattern = "/text/";
$replacement = "example";

$newString = preg_replace($pattern, $replacement, $string);
echo $newString; // выведет "This is some example."
```

* **`preg_split(string $pattern, string $subject, int $limit = -1, int $flags = 0): array|false`** - разбивает строку `$subject` на подстроки, используя шаблон `$pattern` как разделитель. Возвращает массив с подстроками или `false` в случае ошибки.

```php
$string = "apple,banana,orange";
$pattern = "/,/";

$fruits = preg_split($pattern, $string);
print_r($fruits); // выведет массив: ["apple", "banana", "orange"]
```

* **`preg_quote(string $string, string $delimiter = null): string`** - экранирует специальные символы в строке `$string` для использования в шаблоне регулярного выражения.

```php
$string = "This string contains a period.";
$escapedString = preg_quote($string);
echo $escapedString; // выведет "This string contains a period\."
```

### Модификаторы паттернов

Модификаторы позволяют изменить поведение шаблона. 

| Модификатор | Описание                                                |
| :---------- | :------------------------------------------------------ |
| i           | Поиск без учета регистра                               |
| m           | Многострочный поиск                                    |
| s           | Точка (.) также соответствует символу переноса строки   |
| x           | Игнорировать пробелы в шаблоне                        |
| A           | Совпадение с началом строки                           |
| D           | Совпадение с концом строки или перед переносом строки |
| U           | UTF-8 кодировка                                        |

```php
// Пример использования модификатора "i"
$string = "HELLO world";
$pattern = "/hello/i"; // поиск без учета регистра

if (preg_match($pattern, $string)) {
    echo "Совпадение найдено!"; 
}
```

### Продвинутые техники

Регулярные выражения предоставляют множество возможностей для сложного поиска и манипуляций с текстом. Вот некоторые из них:

* **Жадные и ленивые квантификаторы:** Квантификаторы, такие как `*` и `+`, по умолчанию "жадные" – они захватывают максимально возможное количество символов. Чтобы сделать их "ленивыми", нужно добавить знак вопроса `?` после квантификатора.

```php
$string = "This is <b>some</b> text.";
$greedyPattern = "/<.*>/";
$lazyPattern = "/<.*?>/";

preg_match($greedyPattern, $string, $greedyMatch);
preg_match($lazyPattern, $string, $lazyMatch);

echo "Жадный: " . $greedyMatch[0] . "\n"; // выведет "<b>some</b>"
echo "Ленивый: " . $lazyMatch[0]; // выведет "<b>"
```

* **Обратные ссылки:** Позволяют ссылаться на текст, захваченный подмаской. Для этого используется обратная косая черта `\`  и номер подмаски.

```php
$string = "John Doe";
$pattern = "/(\w+) (\w+)/";
$replacement = "$2, $1"; // меняем местами имя и фамилию

$newString = preg_replace($pattern, $replacement, $string);
echo $newString; // выведет "Doe, John"
```

* **Позитивные и негативные lookahead и lookbehind:** Позволяют проверять наличие (или отсутствие) подстроки перед или после текущей позиции, не включая её в результат.

```php
// Пример использования positive lookahead:
$string = "apple123";
$pattern = "/apple(?=\d+)/"; // поиск "apple", за которым следуют цифры

if (preg_match($pattern, $string)) {
    echo "Совпадение найдено!";
}
```

### Заключение

Регулярные выражения – мощный инструмент для обработки текста, но могут быть сложны в освоении. Важно практиковаться и изучать документацию, чтобы использовать их эффективно. Подробную информацию о функциях и синтаксисе регулярных выражений в PHP можно найти в официальной документации: [https://www.php.net/manual/ru/book.pcre.php](https://www.php.net/manual/ru/book.pcre.php)
