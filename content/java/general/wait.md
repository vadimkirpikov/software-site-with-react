## Взаимодействие потоков: методы wait() и notify()

В многопоточной среде Java часто возникает необходимость координировать работу различных потоков. Потоки могут зависеть от результатов выполнения друг друга, и для корректной работы программы важно обеспечить механизм, позволяющий потокам взаимодействовать и синхронизировать свои действия. В Java для этих целей используются методы `wait()`, `notify()` и `notifyAll()`, определенные в классе `Object`.

### Метод wait()

Метод `wait()` используется потоком для ожидания определенного условия. Вызов этого метода приостанавливает выполнение текущего потока до тех пор, пока другой поток не вызовет метод `notify()` или `notifyAll()` для того же объекта-монитора. Монитором называется объект, на котором синхронизируются потоки. Обычно это тот же объект, для которого вызывается метод `wait()`.

**Существует три варианта метода `wait()`:**

* `wait()`: приостанавливает поток на неопределенное время, пока другой поток не вызовет `notify()` или `notifyAll()` для этого объекта.
* `wait(long timeout)`: приостанавливает поток на заданное количество миллисекунд или до вызова `notify()`/`notifyAll()`, в зависимости от того, что наступит раньше.
* `wait(long timeout, int nanos)`: приостанавливает поток на заданное время,  указанное в миллисекундах и наносекундах, или до вызова `notify()`/`notifyAll()`, в зависимости от того, что наступит раньше.

**Важно:** Метод `wait()` может быть вызван только из синхронизированного блока или метода, который захватывает монитор объекта. В противном случае будет выброшено исключение `IllegalMonitorStateException`.

### Методы notify() и notifyAll()

* `notify()`: пробуждает один из потоков, ожидающих на мониторе данного объекта. Выбор потока для пробуждения не определен и зависит от реализации JVM. 
* `notifyAll()`: пробуждает все потоки, ожидающие на мониторе данного объекта.

**Важно:** Методы `notify()` и `notifyAll()` также могут быть вызваны только из синхронизированного блока или метода, который захватывает монитор объекта.

### Пример использования wait() и notify()

Рассмотрим пример с очередью задач. Один поток добавляет задачи в очередь, а другой поток их обрабатывает:

```java
import java.util.LinkedList;
import java.util.Queue;

public class TaskQueue {
    private final Queue<String> tasks = new LinkedList<>();

    public synchronized void addTask(String task) {
        tasks.add(task);
        // Уведомляем ожидающий поток о добавлении новой задачи
        notify();
    }

    public synchronized String getTask() throws InterruptedException {
        // Ожидаем, пока в очереди не появятся задачи
        while (tasks.isEmpty()) {
            wait();
        }
        return tasks.poll();
    }

    public static void main(String[] args) {
        TaskQueue queue = new TaskQueue();

        // Поток-производитель
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                String task = "Задача " + i;
                queue.addTask(task);
                System.out.println("Добавлено: " + task);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        // Поток-потребитель
        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try {
                    String task = queue.getTask();
                    System.out.println("Выполнено: " + task);
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        producer.start();
        consumer.start();
    }
}
```

В этом примере:

1. Класс `TaskQueue` реализует очередь задач с методами `addTask()` и `getTask()`.
2. Метод `addTask()` добавляет задачу в очередь и уведомляет ожидающий поток (потребитель) о наличии новой задачи с помощью `notify()`.
3. Метод `getTask()` извлекает задачу из очереди. Если очередь пуста, поток переходит в состояние ожидания с помощью `wait()`, пока не получит уведомление от потока-производителя.
4. Поток-производитель добавляет 5 задач в очередь с интервалом в 1 секунду.
5. Поток-потребитель извлекает и обрабатывает задачи из очереди с интервалом в 2 секунды.

### Важные моменты

* `wait()` и `notify()` используются вместе для реализации взаимодействия между потоками, основанного на условиях.
* Необходимо использовать синхронизированные блоки или методы для корректной работы с `wait()` и `notify()`.
* `notify()` пробуждает только один поток, в то время как `notifyAll()` пробуждает все ожидающие потоки. 
* После вызова `notify()` или `notifyAll()` текущий поток не освобождает монитор объекта мгновенно. Пробужденный поток сможет продолжить работу только после того, как текущий поток освободит монитор (например, выйдет из synchronized блока).

Понимание принципов работы `wait()` и `notify()`  критически важно для разработки многопоточных приложений на Java. Используя эти методы, можно создавать эффективные и безопасные механизмы синхронизации, которые обеспечивают корректное взаимодействие между потоками.
