## Ссылочные типы и клонирование объектов

В Java все типы данных делятся на две категории: примитивные и ссылочные. В отличие от примитивных типов, которые хранят само значение, ссылочные типы хранят ссылку на объект в памяти. 

### Работа ссылочных переменных

Представьте себе коробку. Примитивная переменная хранит значение непосредственно внутри этой коробки. Ссылочная переменная же хранит в коробке адрес, который указывает на другую коробку, где и находится сам объект.

```java
// Пример с примитивным типом
int a = 5;
int b = a; // Копируется значение

// Пример со ссылочным типом
StringBuilder str1 = new StringBuilder("Hello"); 
StringBuilder str2 = str1; // Копируется ссылка

```

В этом примере `str1` и `str2` ссылаются на один и тот же объект `StringBuilder`. Изменение объекта по одной ссылке (`str1.append(" world!")`) повлияет на данные, доступные по другой ссылке (`str2`).

### Клонирование объектов

Часто требуется создать независимую копию объекта, чтобы изменения в копии не затрагивали оригинал. Для этого используется клонирование.

#### Интерфейс Cloneable

В Java базовый класс `Object` имеет метод `clone()`. Однако, по умолчанию он защищен (`protected`) и кидает исключение `CloneNotSupportedException`, если класс явно не разрешает клонирование, реализуя интерфейс `Cloneable`. 

```java
class Person implements Cloneable { 
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

В данном примере класс `Person` реализует `Cloneable` и переопределяет метод `clone()`, предоставляя публичный доступ к нему. 

#### Поверхностное копирование

Метод `clone()` из класса `Object` выполняет поверхностное копирование. Это означает, что создается новый объект, но поля ссылочного типа  в нем будут указывать на те же объекты, что и поля оригинала.

```java
class Address {
    String street;

    public Address(String street) {
        this.street = street;
    }
}

class Person implements Cloneable { 
    String name;
    int age;
    Address address;

    // ... (остальной код как в предыдущем примере)
}

// ...

Person person1 = new Person("Иван", 30);
person1.address = new Address("ул. Ленина");

Person person2 = (Person) person1.clone(); 
person2.name = "Петр"; // Изменяем поле примитивного типа
person2.address.street = "ул. Пушкина"; // Изменяем поле ссылочного типа

```

В результате,  изменение `street` у `person2` также изменит `street` у `person1`, так как они ссылаются на один и тот же объект `Address`.

#### Глубокое копирование

Для создания полностью независимой копии, включая объекты, на которые есть ссылки, нужно реализовать глубокое копирование.  Это подразумевает создание новых экземпляров объектов для всех полей ссылочного типа.

```java
class Person implements Cloneable { 
    // ... (остальной код)

    @Override
    public Object clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = new Address(this.address.street); // Глубокое копирование Address
        return cloned;
    }
}
```

Теперь при изменении `street` у `person2`,  `street` у `person1` останется прежним, так как у каждого объекта `Person` теперь свой независимый объект `Address`.

### Заключение

Клонирование – важный инструмент для работы со ссылочными типами в Java. Понимание разницы между поверхностным и глубоким копированием поможет избежать ошибок и писать более предсказуемый код.
