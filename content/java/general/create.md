<h2>Создание и выполнение потоков</h2>

Потоки (threads) являются неотъемлемой частью параллельного программирования в Java. Они позволяют выполнять несколько задач "одновременно", что может значительно повысить производительность приложения, особенно на многоядерных процессорах.

В Java каждый поток представлен экземпляром класса `Thread`.  Для создания потока существует два основных способа:

**1. Реализация интерфейса `Runnable`:**

   - Создайте класс, который реализует интерфейс `Runnable`.
   - Переопределите метод `run()`, в котором опишите код, который будет выполняться в новом потоке.
   - Создайте экземпляр вашего класса.
   - Создайте новый объект `Thread`, передав ему экземпляр вашего класса в конструктор.
   - Запустите поток, вызвав метод `start()` у объекта `Thread`.

   **Пример:**

   ```java
   public class MyRunnable implements Runnable {
       @Override
       public void run() {
           System.out.println("Код выполняется в новом потоке!");
       }
   }

   public class Main {
       public static void main(String[] args) {
           MyRunnable runnable = new MyRunnable();
           Thread thread = new Thread(runnable);
           thread.start();
       }
   }
   ```

**2. Наследование от класса `Thread`:**

   - Создайте класс, который наследуется от класса `Thread`.
   - Переопределите метод `run()`, в котором опишите код, который будет выполняться в новом потоке.
   - Создайте экземпляр вашего класса.
   - Запустите поток, вызвав метод `start()` у созданного экземпляра.

   **Пример:**

   ```java
   public class MyThread extends Thread {
       @Override
       public void run() {
           System.out.println("Код выполняется в новом потоке!");
       }
   }

   public class Main {
       public static void main(String[] args) {
           MyThread thread = new MyThread();
           thread.start();
       }
   }
   ```

**Выбор между `Runnable` и наследованием от `Thread`:**

- Если вам нужно, чтобы ваш класс наследовал другой класс, используйте `Runnable`. В Java класс может наследовать только один класс, но может реализовывать несколько интерфейсов.
- Если вам не нужно наследование от другого класса, оба варианта равнозначны.

**Жизненный цикл потока:**

1. **New (Новый):** Поток создается, но еще не запущен.
2. **Runnable (Готов к выполнению):** Поток готов к выполнению, но ожидает, пока планировщик потоков назначит его на выполнение.
3. **Running (Выполняется):** Поток выполняется на процессоре.
4. **Blocked (Заблокирован):** Поток приостановлен и ожидает какого-либо события (например, доступа к синхронизированному ресурсу).
5. **Terminated (Завершен):** Поток завершил свое выполнение.

**Методы класса `Thread`:**

| Метод                 | Описание                                                                          |
|----------------------|---------------------------------------------------------------------------------|
| `start()`            | Запускает поток.                                                                     |
| `run()`             | Содержит код, который будет выполняться в новом потоке.                        |
| `sleep(long millis)` | Приостанавливает поток на заданное количество миллисекунд.                        |
| `join()`             | Ожидает завершения выполнения потока.                                              |
| `interrupt()`        | Посылает потоку запрос на прерывание.                                            |
| `isInterrupted()`    | Возвращает `true`, если поток был прерван.                                         |
| `isAlive()`          | Возвращает `true`, если поток запущен и не завершен.                             |
| `currentThread()`     | Возвращает ссылку на текущий поток.                                               |

**Пример использования метода `sleep()`:**

```java
public class SleepExample {
    public static void main(String[] args) {
        System.out.println("Начало работы программы.");

        try {
            Thread.sleep(2000); // Пауза на 2 секунды
        } catch (InterruptedException e) {
            System.out.println("Поток был прерван.");
        }

        System.out.println("Конец работы программы.");
    }
}
```

**Пример использования метода `join()`:**

```java
public class JoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Поток: " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    System.out.println("Поток был прерван.");
                }
            }
        });

        thread.start();
        thread.join(); // Ожидание завершения потока

        System.out.println("Основной поток завершен.");
    }
}
```

В этом примере, основной поток вызывает метод `join()` для дочернего потока. Это приводит к тому, что основной поток блокируется и ожидает, пока дочерний поток не завершит свою работу. После завершения дочернего потока, основной поток продолжает свое выполнение.

**Важно:** 

* Не вызывайте метод `run()` напрямую. Используйте `start()` для запуска потока. Вызов `run()` напрямую приведет к выполнению кода в текущем потоке, а не в новом.
* Потоки работают параллельно, и порядок их выполнения не гарантирован.
* При работе с потоками важно учитывать синхронизацию доступа к общим ресурсам, чтобы избежать ошибок concurrency.