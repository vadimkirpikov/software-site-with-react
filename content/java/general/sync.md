## Синхронизация потоков. Оператор synchronized

Многопоточность — неотъемлемая часть современных приложений. Она позволяет эффективно использовать ресурсы процессора, выполняя несколько задач "параллельно". Однако, когда несколько потоков одновременно работают с общими данными, возникает риск возникновения состояний гонки (race conditions), которые могут привести к непредсказуемому поведению программы. 

Рассмотрим пример:

```java
class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

В этом примере класс `Counter` хранит счетчик `count`. Метод `increment()` увеличивает счетчик на единицу. Предположим, два потока одновременно вызывают метод `increment()`. 

1. Первый поток считывает значение `count` (равное 0). 
2. Второй поток считывает значение `count` (также равное 0).
3. Первый поток увеличивает значение `count` на единицу (теперь `count` равно 1).
4. Второй поток увеличивает значение `count` на единицу (теперь `count` равно 1).

В результате, несмотря на два вызова `increment()`, значение `count` будет равно 1 вместо ожидаемого 2. Это и есть состояние гонки.

Для предотвращения подобных ситуаций используется **синхронизация потоков**.  В Java для этого используется ключевое слово `synchronized`. 

### Ключевое слово synchronized

Ключевое слово `synchronized` позволяет обеспечить **взаимоисключение** при доступе к общему ресурсу. Это означает, что в каждый момент времени только один поток может получить доступ к блоку кода, защищенному `synchronized`. 

Существует два основных способа использования `synchronized`:

1. **Синхронизированные блоки:**

   ```java
   synchronized (object) {
       // Код, который должен выполняться синхронно
   }
   ```

   В этом случае объект `object` выступает в роли **монитора**. Монитор — это механизм, который гарантирует, что только один поток может "владеть" им в каждый момент времени. 

2. **Синхронизированные методы:**

   ```java
   public synchronized void methodName() {
       // Код, который должен выполняться синхронно
   }
   ```

   Синхронизированный метод — это метод, к которому применяется модификатор `synchronized`. В этом случае монитором выступает сам объект, к которому принадлежит метод.

**Пример:**

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

В этом примере мы добавили ключевое слово `synchronized` к методам `increment()` и `getCount()`. Теперь только один поток может одновременно выполнять любой из этих методов. 

**Важно:**

* Выбор объекта-монитора зависит от конкретной ситуации. 
* Использование `synchronized` может снизить производительность приложения, поэтому важно использовать его только при необходимости.

### Практический пример

```java
public class SynchronizedCounterExample {

    public static void main(String[] args) {
        Counter counter = new Counter();

        // Создаем два потока
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter.increment();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter.increment();
            }
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();

        // Ожидаем завершения потоков
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Выводим значение счетчика
        System.out.println("Count: " + counter.getCount());
    }
}
```

В этом примере два потока увеличивают значение счетчика на 1 000 000 каждый. Благодаря `synchronized` конечное значение счетчика будет равно 2 000 000, что демонстрирует корректную работу синхронизации.

### Заключение

Синхронизация потоков — важный аспект многопоточного программирования. Оператор `synchronized` предоставляет простой и эффективный способ решения проблем, связанных с состоянием гонки, обеспечивая корректную работу приложения в многопоточной среде.
