## Условия в блокировках

Многопоточные приложения часто требуют координации работы потоков. Блокировки (locks) предоставляют механизм взаимного исключения, гарантирующий, что только один поток может получить доступ к разделяемому ресурсу в определенный момент времени. Однако простое использование блокировок не всегда достаточно. Иногда потокам необходимо ждать выполнения определенных условий, прежде чем они смогут продолжить работу. В таких случаях используются условия в блокировках.

### Интерфейс Condition

Java предоставляет интерфейс `java.util.concurrent.locks.Condition`, который расширяет функциональность блокировок, позволяя потокам ждать и уведомлять друг друга об изменении состояния. Интерфейс `Condition` ассоциируется с конкретным объектом блокировки (`Lock`).  

Основные методы интерфейса `Condition`:

| Метод              | Описание                                                                                                      |
|---------------------|-----------------------------------------------------------------------------------------------------------------|
| `await()`           | Приостанавливает текущий поток до тех пор, пока он не будет прерван или не получит уведомление.                 |
| `signal()`         | Пробуждает один из потоков, ожидающих на этом условии.                                                         |
| `signalAll()`      | Пробуждает все потоки, ожидающие на этом условии.                                                            |

### Использование условий в блокировках

Рассмотрим пример использования условий в блокировках. Представим приложение, в котором два потока работают с очередью: поток-производитель добавляет элементы в очередь, а поток-потребитель извлекает их.

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class BlockingQueueExample {

    private static final int QUEUE_CAPACITY = 10;

    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        Lock lock = new ReentrantLock();
        Condition notFull = lock.newCondition(); // Условие: очередь не заполнена
        Condition notEmpty = lock.newCondition(); // Условие: очередь не пуста

        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 20; i++) {
                lock.lock();
                try {
                    // Если очередь заполнена, ждать, пока не освободится место
                    while (queue.size() == QUEUE_CAPACITY) {
                        notFull.await();
                    }
                    queue.add(i);
                    System.out.println("Производитель добавил: " + i);
                    // Уведомляем потребителя, что в очереди есть элемент
                    notEmpty.signal();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock.unlock();
                }
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 20; i++) {
                lock.lock();
                try {
                    // Если очередь пуста, ждать, пока не появится элемент
                    while (queue.isEmpty()) {
                        notEmpty.await();
                    }
                    int value = queue.poll();
                    System.out.println("Потребитель получил: " + value);
                    // Уведомляем производителя, что в очереди освободилось место
                    notFull.signal();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock.unlock();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}
```

В этом примере:

1. Создаётся объект `ReentrantLock` для управления доступом к очереди.
2. С помощью метода `newCondition()` создаются два объекта `Condition`, ассоциированные с блокировкой: `notFull` (условие, что очередь не заполнена) и `notEmpty` (условие, что очередь не пуста).
3. Поток-производитель, прежде чем добавить элемент в очередь, проверяет, не заполнена ли она (`queue.size() == QUEUE_CAPACITY`). Если очередь заполнена, поток вызывает `notFull.await()`, чтобы ждать освобождения места.  
4. Поток-потребитель, прежде чем извлечь элемент из очереди, проверяет, не пуста ли она (`queue.isEmpty()`). Если очередь пуста, поток вызывает `notEmpty.await()`, чтобы ждать появления элемента.
5. После добавления элемента производитель вызывает `notEmpty.signal()`, чтобы уведомить потребителя о том, что в очереди появился элемент. 
6. После извлечения элемента потребитель вызывает `notFull.signal()`, чтобы уведомить производителя о том, что в очереди освободилось место.

### Важные моменты

* Условия всегда связаны с конкретным объектом блокировки.
* Перед вызовом методов `await()`, `signal()` или `signalAll()` необходимо захватить блокировку, связанную с условием.
* Метод `await()` освобождает блокировку, позволяя другим потокам получить доступ к разделяемому ресурсу.
* После пробуждения потока с помощью `signal()` или `signalAll()` нет гарантии, что он сразу же получит блокировку.
* Всегда используйте конструкции `while` для проверки условий после выхода из `await()`, чтобы избежать ложных пробуждений.


Использование условий в блокировках позволяет создавать более сложные и эффективные механизмы синхронизации потоков, чем простое использование блокировок.