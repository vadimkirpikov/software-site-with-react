## Группировка данных в Java

Часто при работе с коллекциями данных возникает необходимость сгруппировать элементы по определенному критерию. Java предоставляет мощные инструменты для реализации такой функциональности.

### Использование Stream API для группировки

Java Stream API, представленный в Java 8, предоставляет элегантный и лаконичный способ группировки данных с использованием лямбда-выражений и функциональных интерфейсов.

#### Метод `collect(Collectors.groupingBy())`

Ключевым методом для группировки является `collect(Collectors.groupingBy())`. Он принимает на вход функцию-классификатор, которая определяет, по какому критерию будут сгруппированы элементы.

Рассмотрим пример. Допустим, у нас есть список объектов `Person`:

```java
record Person(String name, int age) {}

List<Person> people = List.of(
    new Person("Иван", 25),
    new Person("Мария", 30),
    new Person("Петр", 25),
    new Person("Анна", 35)
);
```

Мы хотим сгруппировать людей по возрасту. Для этого передадим в `groupingBy()` лямбда-выражение, возвращающее возраст человека:

```java
Map<Integer, List<Person>> peopleByAge = people.stream()
    .collect(Collectors.groupingBy(Person::age));
```

В результате выполнения кода будет создана карта `peopleByAge`, где ключом является возраст, а значением - список людей с этим возрастом.

#### Группировка по составному ключу

Иногда требуется сгруппировать данные по нескольким критериям. Для этого можно использовать вложенные вызовы `groupingBy()`.

Например, сгруппируем людей сначала по возрасту, а затем по первой букве имени:

```java
Map<Integer, Map<Character, List<Person>>> peopleByAgeAndName = people.stream()
    .collect(Collectors.groupingBy(Person::age,
        Collectors.groupingBy(p -> p.name().charAt(0))));
```

В этом случае результатом будет карта, где ключом первого уровня является возраст, ключом второго уровня - первая буква имени, а значением - список людей, соответствующих этим критериям.

#### Изменение типа результата группировки

По умолчанию `groupingBy()` возвращает `List` для хранения сгруппированных элементов. Изменить тип результата можно с помощью перегруженного метода `groupingBy()`, принимающего на вход второй аргумент - коллектор downstream.

Например, получим множество имен людей для каждого возраста:

```java
Map<Integer, Set<String>> namesByAge = people.stream()
    .collect(Collectors.groupingBy(Person::age,
        Collectors.mapping(Person::name, Collectors.toSet())));
```

В данном примере используется `Collectors.mapping()` для преобразования `Person` в `String` (имя) и `Collectors.toSet()` для сбора имен в множество.

#### Подсчет количества элементов в группе

Для подсчета количества элементов в каждой группе можно использовать `Collectors.counting()`:

```java
Map<Integer, Long> countByAge = people.stream()
    .collect(Collectors.groupingBy(Person::age, Collectors.counting()));
```

В результате `countByAge` будет содержать количество людей для каждого возраста.

### Заключение

Группировка данных - важная операция при обработке коллекций. Java предоставляет гибкие и мощные инструменты для реализации этой функциональности. Использование Stream API и метода `collect(Collectors.groupingBy())` делает код лаконичным, читаемым и легко модифицируемым. 
