## Обобщения (Generics) в Java

Обобщения, представленные в Java 5, являются мощным инструментом, позволяющим писать более типобезопасный и гибкий код. Вместо работы с конкретными типами данных, обобщения позволяют писать код, который может работать с различными типами, не теряя при этом информацию о типе.

### Базовое использование обобщений

Рассмотрим простой пример: создание списка целых чисел. До появления обобщений мы бы использовали `List`, который мог хранить объекты любого типа:

```java
List list = new ArrayList();
list.add(1); 
list.add("string"); // Допустимо, но может привести к ошибкам в будущем
```

Проблема этого подхода заключается в том, что мы теряем информацию о типе данных, хранящихся в списке. При извлечении элемента из списка нам пришлось бы выполнять приведение типа, что может привести к ошибкам `ClassCastException`, если тип будет неверным.

Обобщения решают эту проблему, позволяя указать тип данных, которые будет хранить список:

```java
List<Integer> list = new ArrayList<>(); // Список, хранящий только целые числа
list.add(1);
// list.add("string"); // Ошибка компиляции!
```

Теперь компилятор знает, что список `list` может содержать только объекты типа `Integer`. Любая попытка добавить объект другого типа приведет к ошибке компиляции.

### Определение обобщенных классов и методов

Обобщения можно использовать не только с классами коллекций, но и для создания собственных обобщенных классов и методов.

#### Обобщенные классы

Пример обобщенного класса `Box`, который может хранить объект любого типа:

```java
public class Box<T> { // T - параметр типа
    private T value;

    public Box(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

В данном примере `T` - это параметр типа, который будет заменен на конкретный тип при создании экземпляра класса `Box`:

```java
Box<Integer> intBox = new Box<>(10);
int intValue = intBox.getValue();

Box<String> stringBox = new Box<>("Hello");
String stringValue = stringBox.getValue();
```

#### Обобщенные методы

Обобщенные методы позволяют параметризовать тип возвращаемого значения и/или типы аргументов:

```java
public static <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.print(element + " ");
    }
    System.out.println();
}
```

Пример использования обобщенного метода `printArray`:

```java
Integer[] intArray = {1, 2, 3};
String[] stringArray = {"Hello", "World"};

printArray(intArray); // Вывод: 1 2 3 
printArray(stringArray); // Вывод: Hello World 
```

### Ограниченные типы (Bounded Type Parameters)

Иногда требуется ограничить типы, которые могут быть использованы в качестве параметров типа. Например,  мы можем захотеть создать метод, который работает только с числами.

Для ограничения типа используется ключевое слово `extends`, за которым следует класс или интерфейс, ограничивающий тип:

```java
public static <T extends Number> double getAverage(T[] array) {
    double sum = 0;
    for (T element : array) {
        sum += element.doubleValue();
    }
    return sum / array.length;
}
```

В данном примере `T extends Number` означает, что `T` может быть любым классом, наследующимся от класса `Number` (например, `Integer`, `Double`, `Float` и т.д.).

### Wildcard типы

Wildcard типы, представленные знаком вопроса `?`, используются, когда нам не важен конкретный тип параметра. Существует три вида wildcard типов:

- **Неограниченный wildcard:** `<?>` - представляет любой тип.
- **Wildcard с верхней границей:** `<? extends T>` - представляет тип `T` или любой его подтип.
- **Wildcard с нижней границей:** `<? super T>` - представляет тип `T` или любой его супертип.

Пример использования wildcard типов:

```java
List<?> unknownList = new ArrayList<String>(); // Список с неизвестным типом
List<? extends Number> numberList = new ArrayList<Integer>(); // Список чисел
List<? super Integer> integerList = new ArrayList<Number>(); // Список, содержащий Integer или его супертипы
```

### Заключение

Обобщения - это мощный инструмент, который делает код Java более безопасным, читаемым и гибким. Используя обобщения, можно создавать код, который работает с различными типами данных без необходимости приведения типов и со строгой проверкой типов во время компиляции.
