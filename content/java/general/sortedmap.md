## Работа с отсортированными данными: Интерфейсы SortedMap, NavigableMap и класс TreeMap

В Java часто возникает необходимость хранить пары ключ-значение в отсортированном виде. Для этих целей Java Collections Framework предоставляет интерфейсы `SortedMap` и `NavigableMap`, а также их реализацию - класс `TreeMap`.

### Интерфейс SortedMap

Интерфейс `SortedMap<K,V>` расширяет интерфейс `Map<K,V>` и представляет собой отображение, в котором ключи хранятся в отсортированном порядке. Порядок сортировки определяется либо естественным порядком ключей (если они реализуют интерфейс `Comparable`), либо с помощью `Comparator`, переданного в конструктор.

`SortedMap` предоставляет ряд методов для работы с отсортированными данными:

| Метод                      | Описание                                                                                           |
|-----------------------------|---------------------------------------------------------------------------------------------------- |
| `firstKey()`               | Возвращает первый (наименьший) ключ в отображении.                                                 |
| `lastKey()`                | Возвращает последний (наибольший) ключ в отображении.                                                |
| `headMap(K toKey)`        | Возвращает представление отображения, содержащее все элементы строго меньше заданного ключа.       |
| `tailMap(K fromKey)`      | Возвращает представление отображения, содержащее все элементы больше или равные заданному ключу.    |
| `subMap(K fromKey, K toKey)`| Возвращает представление отображения, содержащее все элементы от `fromKey` (включительно) до `toKey` (исключая). |

### Интерфейс NavigableMap

Интерфейс `NavigableMap<K,V>` расширяет интерфейс `SortedMap<K,V>` и предоставляет дополнительные методы навигации по отсортированному отображению:

| Метод                   | Описание                                                                                                                                  |
|--------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| `lowerKey(K key)`       | Возвращает наибольший ключ, строго меньший заданного ключа.                                                                                   |
| `floorKey(K key)`       | Возвращает наибольший ключ, меньший или равный заданному ключу.                                                                               |
| `ceilingKey(K key)`     | Возвращает наименьший ключ, строго больший заданного ключа.                                                                                   |
| `higherKey(K key)`      | Возвращает наименьший ключ, больший или равный заданному ключу.                                                                               |
| `pollFirstEntry()`       | Удаляет и возвращает запись с наименьшим ключом.                                                                                             |
| `pollLastEntry()`        | Удаляет и возвращает запись с наибольшим ключом.                                                                                             |
| `descendingMap()`       | Возвращает представление отображения с обратным порядком сортировки.                                                                         |
| `navigableKeySet()`      | Возвращает навигируемое множество ключей отображения.                                                                                          |
| `descendingKeySet()`     | Возвращает навигируемое множество ключей отображения с обратным порядком.                                                                     |

### Класс TreeMap

`TreeMap<K,V>` - это реализация интерфейса `NavigableMap`, основанная на красно-черном дереве. Красно-черные деревья - это самобалансирующиеся бинарные деревья поиска, которые гарантируют логарифмическую временную сложность для основных операций (`put`, `get`, `remove`).

#### Создание TreeMap

```java
// Создание пустого TreeMap с естественным порядком ключей
TreeMap<String, Integer> map1 = new TreeMap<>();

// Создание TreeMap с компаратором для сортировки ключей в обратном порядке
TreeMap<String, Integer> map2 = new TreeMap<>(Comparator.reverseOrder());

// Создание TreeMap на основе другого SortedMap
SortedMap<String, Integer> sortedMap = new TreeMap<>();
sortedMap.put("apple", 1);
sortedMap.put("banana", 2);
TreeMap<String, Integer> map3 = new TreeMap<>(sortedMap); 
```

#### Основные операции

```java
TreeMap<String, Integer> map = new TreeMap<>();

// Добавление элементов
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);

// Получение элемента по ключу
int value = map.get("banana"); // value = 2

// Проверка наличия ключа
boolean containsKey = map.containsKey("apple"); // containsKey = true

// Удаление элемента по ключу
map.remove("banana");

// Размер отображения
int size = map.size(); // size = 2

// Итерация по элементам
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

#### Использование методов NavigableMap

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(1, "One");
map.put(3, "Three");
map.put(5, "Five");

// Находим наибольший ключ, строго меньший 4
int lowerKey = map.lowerKey(4); // lowerKey = 3

// Находим наименьший ключ, больший или равный 4
int ceilingKey = map.ceilingKey(4); // ceilingKey = 5

// Получаем представление отображения с ключами от 2 (включительно) до 5 (исключая)
NavigableMap<Integer, String> subMap = map.subMap(2, false, 5, false);
```

### Выбор между HashMap и TreeMap

| Характеристика   | HashMap                             | TreeMap                                 |
|------------------|--------------------------------------|-----------------------------------------|
| Порядок ключей   | Не гарантируется                    | Отсортированы по ключам                 |
| Производительность| `get`, `put`, `remove`: O(1) в среднем | `get`, `put`, `remove`: O(log n)       |
| Использование    | Когда порядок ключей не важен       | Когда ключи должны быть отсортированы |

Выбор между `HashMap` и `TreeMap` зависит от требований к  приложению. Если важна производительность для операций `get`, `put` и `remove` и порядок ключей не важен, то `HashMap` будет лучшим выбором. Если же необходимо хранить ключи в отсортированном виде, то следует использовать `TreeMap`, помня о том, что это повлечет за собой некоторое снижение производительности. 
