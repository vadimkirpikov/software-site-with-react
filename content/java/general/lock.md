## Блокировки и ReentrantLock

В многопоточной среде Java, где несколько потоков выполняются одновременно, доступ к общим ресурсам может привести к непредсказуемым результатам. Для обеспечения целостности данных и предотвращения race conditions, используются механизмы синхронизации, такие как блокировки.

Блокировка предоставляет механизм эксклюзивного доступа к ресурсу. Только один поток может удерживать блокировку в определенный момент времени. 

### ReentrantLock

`ReentrantLock` - это реализация блокировки, предоставляющая более гибкий контроль над синхронизацией, чем ключевое слово `synchronized`. `ReentrantLock` является **реентерабельной** блокировкой, это означает, что поток, уже удерживающий блокировку, может получить ее снова без блокировки.

#### Создание и использование ReentrantLock

Для использования `ReentrantLock` необходимо создать экземпляр класса `java.util.concurrent.locks.ReentrantLock`:

```java
ReentrantLock lock = new ReentrantLock();
```

Для получения блокировки используется метод `lock()`:

```java
lock.lock(); 
```

Для освобождения блокировки используется метод `unlock()`:

```java
lock.unlock();
```

Важно вызывать метод `unlock()` в блоке `finally`, чтобы гарантировать освобождение блокировки даже в случае возникновения исключения.

**Пример:**

```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {

    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // Получаем блокировку
        try {
            count++;
        } finally {
            lock.unlock(); // Освобождаем блокировку в блоке finally
        }
    }

    public int getCount() {
        return count;
    }
}
```

В этом примере, метод `increment()` использует `ReentrantLock` для защиты доступа к переменной `count`. 

#### Методы ReentrantLock

Помимо `lock()` и `unlock()`, `ReentrantLock` предоставляет дополнительные методы:

- `tryLock()`: пытается получить блокировку, не блокируя поток, если блокировка недоступна. Возвращает `true`, если блокировка была успешно получена, и `false` в противном случае.

- `tryLock(long time, TimeUnit unit)`: пытается получить блокировку в течение заданного времени.

- `newCondition()`: создает объект `Condition`, связанный с этой блокировкой. Объекты `Condition` позволяют реализовывать более сложные схемы синхронизации, такие как ожидание и уведомление.

#### Преимущества ReentrantLock

- **Гибкость:** ReentrantLock предоставляет более точный контроль над синхронизацией по сравнению с `synchronized`.

- **Производительность:** В некоторых случаях `ReentrantLock` может обеспечить лучшую производительность, чем `synchronized`, особенно при высокой конкуренции.

- **Дополнительные возможности:** ReentrantLock предлагает дополнительные функции, такие как `tryLock()` и `newCondition()`, которые недоступны при использовании `synchronized`.

#### Недостатки ReentrantLock

- **Сложность:** Использование `ReentrantLock` требует более явного управления блокировками и может быть более подвержено ошибкам, чем `synchronized`.

- **Риск взаимоблокировок:** Неправильное использование `ReentrantLock` может привести к взаимоблокировкам.

**Рекомендации:**

- Используйте `ReentrantLock`, когда необходим более точный контроль над синхронизацией, чем предоставляет `synchronized`.

- Всегда освобождайте блокировку в блоке `finally`.

- Тщательно анализируйте код на наличие потенциальных взаимоблокировок.


## Заключение

`ReentrantLock` - мощный инструмент для синхронизации доступа к общим ресурсам в многопоточных приложениях Java.  Важно понимать преимущества и недостатки `ReentrantLock`  и использовать его с осторожностью, чтобы избежать потенциальных проблем. 
