## Работа с наследованием в Hibernate 6

Hibernate предоставляет мощные механизмы для отображения наследования в объектно-ориентированных моделях на реляционные базы данных. В этой статье мы рассмотрим различные стратегии отображения наследования, предлагаемые Hibernate 6, и подробно разберем их применение на практических примерах.

### Стратегии наследования

Hibernate поддерживает три основных стратегии наследования:

1. **Таблица на одну иерархию классов (Table per class hierarchy):** Все классы в иерархии наследования отображаются на одну таблицу. 
2. **Таблица на подкласс (Table per subclass):** Для каждого подкласса создается отдельная таблица, содержащая только поля, специфичные для этого подкласса.
3. **Таблица на конкретный класс (Table per concrete class):**  Для каждого конкретного (не абстрактного) класса создается отдельная таблица, содержащая все его поля, включая унаследованные.

Выбор оптимальной стратегии зависит от конкретной ситуации и требований к производительности и структуре базы данных.

### Таблица на одну иерархию классов

Эта стратегия предполагает использование одной таблицы для хранения всех классов иерархии. Для различения объектов разных типов вводится дискриминатор - специальный столбец, хранящий информацию о типе объекта. 

**Пример:**

```java
// Суперкласс
@Entity
@Table(name = "animals")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "animal_type", discriminatorType = DiscriminatorType.STRING)
public abstract class Animal {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@DiscriminatorValue("Dog")
public class Dog extends Animal {

    private String breed;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@DiscriminatorValue("Cat")
public class Cat extends Animal {

    private boolean indoor;

    // Геттеры и сеттеры
}
```

В этом примере все животные (Animal, Dog, Cat) будут храниться в одной таблице "animals". Столбец "animal_type" будет использоваться для определения типа животного.

**Преимущества:**

* Простота реализации и запросов.
* Эффективность выборки данных для всей иерархии.

**Недостатки:**

* Возможны пустые столбцы для атрибутов, не принадлежащих конкретному типу.
* Сложность добавления новых атрибутов в суперкласс, так как это требует изменения структуры таблицы.

### Таблица на подкласс

При использовании этой стратегии для каждого подкласса создается отдельная таблица, наследующая первичный ключ от таблицы суперкласса.

**Пример:**

```java
// Суперкласс
@Entity
@Table(name = "vehicles")
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Vehicle {

    @Id
    @GeneratedValue
    private Long id;

    private String brand;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@Table(name = "cars")
@PrimaryKeyJoinColumn(name = "vehicle_id")
public class Car extends Vehicle {

    private int numberOfDoors;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@Table(name = "motorcycles")
@PrimaryKeyJoinColumn(name = "vehicle_id")
public class Motorcycle extends Vehicle {

    private int engineCapacity;

    // Геттеры и сеттеры
}
```

В этом примере будут созданы три таблицы: "vehicles", "cars" и "motorcycles". Таблицы "cars" и "motorcycles" будут ссылаться на таблицу "vehicles" по первичному ключу.

**Преимущества:**

* Гибкость в проектировании подклассов и добавлении новых атрибутов.
* Отсутствие пустых столбцов.

**Недостатки:**

* Сложность запросов, затрагивающих несколько таблиц.
* Потенциальное снижение производительности при выборке данных из подклассов.

### Таблица на конкретный класс

В этой стратегии для каждого конкретного (не абстрактного) класса создается отдельная таблица, содержащая все его поля, включая унаследованные.

**Пример:**

```java
// Суперкласс (абстрактный)
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Shape {

    @Id
    @GeneratedValue
    private Long id;

    private String color;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@Table(name = "circles")
public class Circle extends Shape {

    private double radius;

    // Геттеры и сеттеры
}

// Подкласс
@Entity
@Table(name = "rectangles")
public class Rectangle extends Shape {

    private double width;
    private double height;

    // Геттеры и сеттеры
}
```

В этом примере будут созданы две таблицы: "circles" и "rectangles".  Каждая таблица будет содержать все поля своего класса, включая унаследованные от Shape.

**Преимущества:**

* Простота запросов к конкретным классам.
* Высокая производительность при выборке данных из конкретных классов.

**Недостатки:**

* Дублирование данных в таблицах.
* Запросы, затрагивающие несколько сущностей, могут быть сложными и неэффективными.

## Заключение

Выбор стратегии наследования в Hibernate зависит от конкретных требований проекта. Важно взвесить все преимущества и недостатки каждой стратегии, прежде чем принимать решение.