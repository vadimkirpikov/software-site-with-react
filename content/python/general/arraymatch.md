## Сопоставление с образцом для последовательностей

Python, начиная с версии 3.10, предоставляет мощный инструмент - сопоставление с образцом (pattern matching). Этот механизм позволяет элегантно и лаконично обрабатывать данные, сравнивая их с заданными шаблонами. В этой статье мы рассмотрим применение сопоставления с образцом для работы с массивами - структурами данных, представляющими собой упорядоченные коллекции элементов.

### Основы

Для работы с массивами в контексте pattern matching используется оператор `match` в сочетании с блоками `case`. Синтаксис напоминает привычную конструкцию `switch-case` из других языков программирования, но обладает значительно большей гибкостью и выразительностью.

Рассмотрим простой пример. Допустим, у нас есть список чисел, и мы хотим проверить, начинается ли он с определенной последовательности:

```python
def check_sequence(data):
    match data:
        case [1, 2, *rest]:
            print("Список начинается с 1, 2. Остаток:", rest)
        case [1, *_, 10]:
            print("Список начинается с 1 и заканчивается на 10")
        case _:
            print("Список не соответствует ни одному шаблону")

check_sequence([1, 2, 3, 4, 5])  # Вывод: Список начинается с 1, 2. Остаток: [3, 4, 5]
check_sequence([1, 5, 6, 10])  # Вывод: Список начинается с 1 и заканчивается на 10
check_sequence([2, 3, 4])     # Вывод: Список не соответствует ни одному шаблону
```

В этом примере мы определили функцию `check_sequence`, которая принимает список `data` и сравнивает его с тремя шаблонами:

1. `[1, 2, *rest]`: Проверяет, начинается ли список с элементов `1` и `2`. Если да, то остаток списка сохраняется в переменной `rest`.
2. `[1, *_, 10]`: Проверяет, начинается ли список с `1` и заканчивается ли на `10`. Символ `_` выступает в роли подстановочного знака и игнорирует все элементы между `1` и `10`.
3. `_`: Этот шаблон сработает, если ни один из предыдущих не подошел.

### Сложные условия

Pattern matching позволяет использовать более сложные условия, включая проверку типов данных и значений элементов. Например:

```python
def analyze_data(data):
    match data:
        case [str(name), int(age)] if age >= 18:
            print(f"{name} (возраст: {age}) - совершеннолетний")
        case [str(name), int(age)]:
            print(f"{name} (возраст: {age}) - несовершеннолетний")
        case _:
            print("Некорректные данные")

analyze_data(["Иван", 25])  # Вывод: Иван (возраст: 25) - совершеннолетний
analyze_data(["Мария", 16]) # Вывод: Мария (возраст: 16) - несовершеннолетний
analyze_data([123, "текст"])# Вывод: Некорректные данные 
```

В этом примере мы проверяем, является ли первый элемент строкой, а второй - целым числом. Дополнительно, с помощью конструкции `if` мы проверяем возраст на совершеннолетие.

### Вложенные структуры

Сопоставление с образцом отлично подходит для работы с вложенными структурами, такими как списки списков:

```python
def process_matrix(matrix):
  match matrix:
    case [[1, *rest], *other_rows]:
      print(f"Первая строка начинается с 1, остаток: {rest}")
      print(f"Остальные строки: {other_rows}")
    case [[a, b], [c, d]]:
      print(f"Матрица 2x2: a={a}, b={b}, c={c}, d={d}")
    case _:
      print("Неизвестный формат матрицы")

process_matrix([[1, 2, 3], [4, 5, 6]])  
# Вывод: 
# Первая строка начинается с 1, остаток: [2, 3]
# Остальные строки: [[4, 5, 6]]

process_matrix([[10, 20], [30, 40]])  
# Вывод: Матрица 2x2: a=10, b=20, c=30, d=40
```

В этом примере мы анализируем двумерные списки. В первом шаблоне мы проверяем, начинается ли первая строка с `1`, а во втором - является ли матрица матрицей 2x2.

### Заключение

Сопоставление с образцом предоставляет удобный и выразительный способ работы с массивами в Python. С помощью этого механизма можно легко проверять структуру массивов, типы данных и значения элементов, а также разбирать вложенные структуры.  Pattern matching делает код более читаемым и лаконичным, упрощая обработку сложных структур данных. 
