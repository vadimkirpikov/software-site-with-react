## Декораторы в Python

Декораторы - это мощный инструмент Python, позволяющий модифицировать поведение функций без изменения их кода. Представьте, что у вас есть функция, и вы хотите добавить к ней функциональность, например, логирование или измерение времени выполнения. Вместо того, чтобы изменять код функции напрямую, вы можете использовать декоратор.

### Основы декораторов

В своей основе декоратор - это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию. Давайте разберем простой пример:

```python
def my_decorator(func):
    def wrapper():
        print("Что-то происходит перед вызовом функции.")
        func()
        print("Что-то происходит после вызова функции.")
    return wrapper

def say_hello():
    print("Привет!")

say_hello = my_decorator(say_hello)
say_hello()
```

В этом примере:

1. `my_decorator` - это декоратор. Он принимает функцию `func` в качестве аргумента.
2. Внутри `my_decorator` определяется функция `wrapper`. 
3. `wrapper` вызывает переданную функцию `func`, а также выполняет дополнительный код до и после.
4. `my_decorator` возвращает функцию `wrapper`.
5. Мы "декорируем" функцию `say_hello`, передавая ее в декоратор `my_decorator` и присваивая результат обратно `say_hello`.

Запустив этот код, вы увидите:

```
Что-то происходит перед вызовом функции.
Привет!
Что-то происходит после вызова функции.
```

### Синтаксис `@`

Python предлагает более удобный синтаксис для применения декораторов с помощью символа `@`:

```python
@my_decorator
def say_hello():
    print("Привет!")

say_hello()
```

Этот код эквивалентен предыдущему примеру. Строка `@my_decorator` перед определением `say_hello` автоматически применяет декоратор `my_decorator` к функции `say_hello`.

### Декораторы с аргументами

Декораторы могут принимать собственные аргументы. Для этого нужно добавить еще один уровень вложенности:

```python
def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Привет, {name}!")

greet("Анна")
```

В этом примере:

1. `repeat` - это функция, которая принимает аргумент `num_times`.
2. `decorator_repeat` - это декоратор, который принимает функцию `func`.
3. `wrapper` вызывает `func` нужное количество раз, указанное в `num_times`.
4. `repeat(num_times=3)` возвращает декоратор `decorator_repeat` с установленным значением `num_times`.

### Декораторы для функций с возвращаемыми значениями

В предыдущих примерах наши функции ничего не возвращали. 
Чтобы корректно обработать возвращаемое значение, нужно добавить его обработку в `wrapper`:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то происходит перед вызовом функции.")
        result = func(*args, **kwargs)
        print("Что-то происходит после вызова функции.")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

result = add(2, 3)
print(f"Результат: {result}")
```

### Практические примеры декораторов

Рассмотрим несколько практических примеров использования декораторов:

**1. Логирование:**

```python
def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__} с аргументами: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"Результат функции: {func.__name__}: {result}")
        return result
    return wrapper

@log_function_call
def multiply(a, b):
    return a * b

result = multiply(3, 4)
```

Этот декоратор логирует имя функции, аргументы и возвращаемое значение при каждом вызове функции.

**2. Измерение времени выполнения:**

```python
import time

def timeit(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Функция {func.__name__} выполнялась {end - start:.4f} секунд.")
        return result
    return wrapper

@timeit
def slow_function(n):
    sum = 0
    for i in range(n):
        sum += i
    return sum

result = slow_function(1000000)
```

Этот декоратор измеряет время выполнения декорированной функции и выводит его на экран.

### Заключение

Декораторы – это мощный инструмент Python, позволяющий писать более чистый, модульный и читаемый код. Они находят широкое применение в различных областях, от веб-разработки до машинного обучения. Понимание принципов работы декораторов поможет вам использовать их потенциал в своих проектах. 
