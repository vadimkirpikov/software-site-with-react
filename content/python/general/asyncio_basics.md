## Основы асинхронного программирования с asyncio

Асинхронное программирование в Python позволяет выполнять код не дожидаясь завершения предыдущих операций. Это особенно полезно при работе с задачами, которые подразумевают ожидание, например, сетевые запросы или операции ввода-вывода. В Python для работы с асинхронностью используется модуль `asyncio`.

### Ключевые понятия asyncio

* **Корутины (coroutines):**  Специальные функции, которые могут приостанавливать свое выполнение, не блокируя при этом основной поток. Корутины определяются с помощью ключевого слова `async`.

* **Событийный цикл (event loop):**  Основной компонент `asyncio`, отвечающий за управление выполнением корутин. Он отслеживает за завершением асинхронных операций и возобновляет выполнение корутин, когда это возможно.

* **`await`:**  Ключевое слово, используемое внутри корутин для ожидания завершения асинхронной операции. 

* **Задачи (tasks):**  Обертка над корутинами, которая позволяет запускать и управлять ими в рамках событийного цикла.

### Пример работы с asyncio

```python
import asyncio

async def say_after(delay, what):
    await asyncio.sleep(delay) #  Ожидаем указанное время
    print(what)

async def main():
    print(f"started at {asyncio.get_event_loop_time()}") #  Время запуска
    await say_after(1, 'hello')
    await say_after(2, 'world')
    print(f"finished at {asyncio.get_event_loop_time()}") #  Время завершения

asyncio.run(main()) #  Запускаем событийный цикл
```

В этом примере:

1. `say_after` - корутина, которая принимает время ожидания и сообщение. 
2. `asyncio.sleep(delay)` - асинхронная функция, которая приостанавливает выполнение корутины на заданное время.
3. В функции `main` мы запускаем две корутины `say_after` с разным временем ожидания. 
4. `asyncio.run(main())` создает событийный цикл и запускает в нем функцию `main`.

### Работа с асинхронными функциями

Многие библиотеки предоставляют асинхронные версии своих функций. Например, для работы с HTTP-запросами можно использовать библиотеку `aiohttp`:

```python
import asyncio
import aiohttp

async def fetch_page(url):
    async with aiohttp.ClientSession() as session: #  Создаем асинхронную сессию
        async with session.get(url) as response:  #  Выполняем GET-запрос
            return await response.text() #  Возвращаем текст страницы

async def main():
    page_content = await fetch_page('http://python.org')  #  Получаем содержимое страницы
    print(page_content) #  Выводим содержимое

asyncio.run(main()) 
```

В этом примере:

1. `aiohttp.ClientSession()` создает асинхронную сессию для выполнения HTTP-запросов.
2. `session.get(url)` выполняет асинхронный GET-запрос к указанному URL.
3. `response.text()` асинхронно читает текст ответа.

### Задачи и управление ими

Для более гибкого управления корутинами можно создавать задачи:

```python
import asyncio

async def my_task(name, delay):
    print(f"Task {name}: started")
    await asyncio.sleep(delay)
    print(f"Task {name}: finished")

async def main():
    task1 = asyncio.create_task(my_task("Task 1", 2)) #  Создаем задачу
    task2 = asyncio.create_task(my_task("Task 2", 1)) #  Создаем задачу

    await task1 #  Ожидаем завершения задачи 1
    await task2 #  Ожидаем завершения задачи 2

asyncio.run(main())
```

Здесь `asyncio.create_task(my_task("Task 1", 2))` создает задачу на основе корутины `my_task`.  Мы можем запускать задачи параллельно и ожидать их завершения с помощью `await`.

### Заключение

Это лишь базовые сведения о работе с asyncio. Библиотека предоставляет множество других возможностей, таких как: работа с очередями, синхронизация, обработка ошибок, отмена задач и многое другое. Более подробно ознакомиться с ними можно в официальной документации Python.
