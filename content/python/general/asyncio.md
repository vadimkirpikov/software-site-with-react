## Асинхронное программирование с asyncio

Асинхронное программирование — это парадигма, позволяющая выполнять несколько операций одновременно без ожидания завершения каждой из них. В Python для этого используется модуль `asyncio`, появившийся в версии 3.4 и значительно усовершенствованный в последующих версиях.

### Основы `asyncio`

Ключевыми понятиями `asyncio` являются:

- **Корутины:** Функции, которые могут приостанавливать своё выполнение, возвращая управление другим корутинам.
- **Цикл событий:** Основной компонент `asyncio`, управляющий выполнением корутин и обработкой событий.
- **Задачи:** Запущенные корутины, управляемые циклом событий.

Для объявления корутин используется ключевое слово `async` перед определением функции:

```python
async def my_coroutine():
    # Код корутины
    return "Результат корутины"
```

Запуск корутины напрямую не приводит к её выполнению. Вместо этого, она должна быть передана в цикл событий:

```python
import asyncio

async def main():
    print("Запуск корутины")
    result = await my_coroutine()
    print(f"Результат: {result}")

asyncio.run(main())
```

В данном примере функция `main()` также объявлена как корутина, так как она вызывает другую корутину `my_coroutine()`. Ключевое слово `await` используется для ожидания завершения корутины и получения её результата.

### Работа с задержками

Одной из основных причин использования асинхронного программирования является эффективная работа с задержками, например, при выполнении сетевых запросов. `asyncio` предоставляет функцию `asyncio.sleep()`, симулирующую задержку без блокировки основного потока:

```python
import asyncio

async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    print(f"Запущено в {time.strftime('%X')}")
    await say_after(1, "Привет")
    await say_after(2, "Мир")
    print(f"Завершено в {time.strftime('%X')}")

asyncio.run(main())
```

В этом примере функции `say_after()` имитируют выполнение длительных операций. Благодаря использованию `await asyncio.sleep()`, они не блокируют друг друга, и вывод программы происходит с ожидаемыми задержками.

### Параллельное выполнение корутин

`asyncio` позволяет запускать корутины одновременно с помощью функций `asyncio.gather()` и `asyncio.create_task()`.

`asyncio.gather()` принимает список корутин и ожидает их завершения, возвращая список результатов:

```python
async def factorial(name, number):
    f = 1
    for i in range(2, number + 1):
        print(f"Задача {name}: Вычисление факториала {i}")
        await asyncio.sleep(1)
        f *= i
    return f"Задача {name}: Факториал {number} равен {f}"

async def main():
    results = await asyncio.gather(
        factorial("A", 2),
        factorial("B", 3),
        factorial("C", 4),
    )
    print("\n".join(results))

asyncio.run(main())
```

В этом примере функция `factorial()` вычисляет факториал числа. `asyncio.gather()` запускает три экземпляра `factorial()` параллельно, ожидая завершения всех задач.

`asyncio.create_task()` создаёт задачу из корутины и возвращает объект `Task`:

```python
async def main():
    task1 = asyncio.create_task(factorial("A", 2))
    task2 = asyncio.create_task(factorial("B", 3))
    print(f"Запущено в {time.strftime('%X')}")
    await task1
    await task2
    print(f"Завершено в {time.strftime('%X')}")

asyncio.run(main())
```

Здесь `asyncio.create_task()` создаёт две задачи, которые выполняются параллельно. `await task1` и `await task2` ожидают завершения каждой задачи.

### Обработка ошибок

При работе с асинхронным кодом важно корректно обрабатывать исключения. Исключения, возникающие в корутинах, распространяются на задачи и могут быть перехвачены с помощью блока `try...except`:

```python
async def main():
    try:
        result = await asyncio.gather(
            factorial("A", 2),
            factorial("B", "не число"),  # Вызовет исключение
            factorial("C", 4),
        )
    except TypeError:
        print("Произошла ошибка TypeError")
```

В этом примере попытка вычислить факториал от строки вызовет исключение `TypeError`, которое будет перехвачено блоком `try...except`.

## Заключение

Асинхронное программирование с `asyncio` — мощный инструмент для создания производительных и отзывчивых приложений на Python. В этой статье были рассмотрены основы работы с `asyncio`, включая создание и запуск корутин, работу с задержками, параллельное выполнение задач и обработку ошибок. 

