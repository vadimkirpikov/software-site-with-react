## Модели Django: Структура данных вашего приложения

Модели Django - это основа вашего веб-приложения. Они представляют собой Python-классы, определяющие структуру данных, с которыми будет работать ваше приложение. Каждая модель отображается в таблицу базы данных, а её атрибуты становятся полями этой таблицы. 

### Создание модели

Для определения модели используется файл `models.py`, расположенный в директории вашего приложения. Каждая модель - это класс, наследующий от `django.db.models.Model`.

Рассмотрим пример создания модели `Product` для интернет-магазина:

```python
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.PositiveIntegerField()
```

В этом примере мы определили модель `Product` с четырьмя атрибутами:

* **name**: Название товара, хранится в поле типа `CharField` с максимальной длиной 255 символов.
* **description**: Описание товара, хранится в поле типа `TextField`, которое может содержать текст неограниченной длины.
* **price**: Цена товара, хранится в поле типа `DecimalField` с максимальным количеством цифр 10, из которых 2 знака после запятой.
* **stock**: Количество товара на складе, хранится в поле типа `PositiveIntegerField`, которое может содержать только положительные целые числа.

### Типы полей

Django предоставляет широкий выбор типов полей для хранения различных данных. 

| Тип поля | Описание |
|---|---|
| `AutoField` | Поле автоинкремента, по умолчанию создается для первичного ключа (`id`) |
| `CharField` | Строковое поле фиксированной длины |
| `TextField` | Текстовое поле для хранения больших объемов текста |
| `IntegerField` | Поле для хранения целых чисел |
| `PositiveIntegerField` | Поле для хранения положительных целых чисел |
| `DecimalField` | Поле для хранения десятичных чисел с фиксированной точностью |
| `BooleanField` | Логическое поле, хранящее True/False значения |
| `DateField` | Поле для хранения даты |
| `DateTimeField` | Поле для хранения даты и времени |
| `EmailField` | Поле для хранения адреса электронной почты |
| `ForeignKey` | Определяет связь "один-ко-многим" с другой моделью |
| `ManyToManyField` | Определяет связь "многие-ко-многим" с другой моделью |

### Параметры полей

Каждый тип поля принимает набор параметров, позволяющих настроить его поведение. Некоторые из наиболее часто используемых параметров:

* **primary_key**: Устанавливает поле в качестве первичного ключа таблицы. По умолчанию Django создает поле `id` типа `AutoField` в качестве первичного ключа.
* **max_length**: Задает максимальную длину строкового поля.
* **unique**:  Устанавливает ограничение уникальности значения поля.
* **null**: Определяет, может ли поле принимать значение NULL. По умолчанию False.
* **blank**: Определяет, может ли поле быть пустым. По умолчанию False.
* **default**: Задает значение по умолчанию для поля.
* **choices**: Предоставляет пользователю список предопределенных вариантов выбора.
* **verbose_name**: Задает удобочитаемое имя поля, используемое в формах и админке Django.

Пример использования параметров:

```python
class Customer(models.Model):
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=100, verbose_name='Имя')
    last_name = models.CharField(max_length=100, blank=True, verbose_name='Фамилия')
    is_active = models.BooleanField(default=True)
```

В этом примере:

* Поле `email` имеет ограничение уникальности, 
* Поле `first_name` имеет удобочитаемое имя "Имя" и ограничение на максимальное количество символов,
* Поле `last_name` может быть пустым, 
* По умолчанию для поля `is_active` установлено значение True.

### Создание связей между моделями

Django поддерживает три типа связей между моделями:

* **один-ко-многим (`ForeignKey`)**: Используется, когда один объект модели A связан с несколькими объектами модели B, но каждый объект модели B связан только с одним объектом модели A (например, автор и его книги).

```python
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=255)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
```

В этом примере, одна книга (`Book`) может иметь только одного автора (`Author`), но один автор может написать несколько книг. Опция `on_delete=models.CASCADE` указывает, что при удалении автора, все его книги также будут удалены. 

* **многие-ко-многим (`ManyToManyField`)**: Используется, когда один объект модели A может быть связан с несколькими объектами модели B, и наоборот (например, статья и её теги).

```python
class Article(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField()
    tags = models.ManyToManyField('Tag')

class Tag(models.Model):
    name = models.CharField(max_length=50)
```

Здесь одна статья может иметь несколько тегов, и один тег может быть у нескольких статей.

* **один-к-одному (`OneToOneField`)**: Используется, когда один объект модели A связан только с одним объектом модели B, и наоборот (например, пользователь и его профиль).

```python
from django.contrib.auth.models import User

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField(blank=True)
    location = models.CharField(max_length=100, blank=True)
```

В этом примере, один пользователь (`User`) может иметь только один профиль (`Profile`), и наоборот.


### Создание миграций и применение изменений к базе данных

После того как вы определили модели, необходимо создать миграции - файлы, содержащие инструкции по изменению структуры базы данных в соответствии с вашими моделями. Для этого используется команда `makemigrations`:

```bash
python manage.py makemigrations
```

После создания миграций, примените изменения к базе данных с помощью команды `migrate`:

```bash
python manage.py migrate
```

## Заключение

Модели Django - это мощный инструмент для определения структуры данных вашего приложения. Используя различные типы полей, параметры и связи между моделями, вы можете создавать сложные и эффективные приложения. 
