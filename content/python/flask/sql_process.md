## Выполнение SQL-запросов и обработка результатов

Работа с базами данных – неотъемлемая часть большинства веб-приложений. Flask, будучи микрофреймворком, не навязывает конкретную библиотеку для взаимодействия с базами данных. Однако, он легко интегрируется с популярными инструментами, такими как SQLAlchemy и SQLite. В данной статье мы рассмотрим базовый пример выполнения SQL-запросов и обработки результатов с использованием SQLite и стандартного модуля `sqlite3`.

### Подключение к базе данных

Перед выполнением запросов необходимо установить соединение с базой данных. Для этого используется функция `connect()` модуля `sqlite3`:

```python
import sqlite3

# Подключение к базе данных (создаст файл, если его нет)
conn = sqlite3.connect('example.db')

# Создание объекта курсора
cursor = conn.cursor()
```

В данном примере мы подключаемся к базе данных `example.db`. Если файл базы данных не существует, он будет создан. После подключения создаётся объект курсора (`cursor`), который используется для выполнения запросов и получения результатов.

### Выполнение SQL-запросов

Для выполнения SQL-запросов используется метод `execute()` объекта курсора. Рассмотрим пример создания таблицы и добавления данных:

```python
# Создание таблицы
cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL
    )
''')

# Добавление данных
cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('John Doe', 'john.doe@example.com'))
conn.commit()
```

В первом запросе мы создаем таблицу `users`, если она не существует. Во втором запросе добавляем данные о пользователе. Важно отметить использование параметризованных запросов (знаки вопроса `?`). Это позволяет избежать SQL-инъекций, делая код более безопасным. Метод `commit()` сохраняет изменения в базе данных.

### Получение результатов запроса

Для получения данных из таблицы используется метод `fetchall()`, `fetchone()` или `fetchmany()`:

```python
# Получение всех пользователей
cursor.execute("SELECT * FROM users")
users = cursor.fetchall()

# Вывод данных
for user in users:
    print(f"ID: {user[0]}, Имя: {user[1]}, Email: {user[2]}")

# Получение одного пользователя
cursor.execute("SELECT * FROM users WHERE id = ?", (1,))
user = cursor.fetchone()

# Вывод данных
print(f"ID: {user[0]}, Имя: {user[1]}, Email: {user[2]}")
```

Метод `fetchall()` возвращает список кортежей, где каждый кортеж представляет собой строку из таблицы. Метод `fetchone()` возвращает один кортеж (первую строку результата) или `None`, если результатов нет. Метод `fetchmany(size)` возвращает указанное количество строк.

### Закрытие соединения

После завершения работы с базой данных важно закрыть соединение:

```python
# Закрытие соединения
conn.close()
```

### Интеграция с Flask

Для использования базы данных в приложении Flask, рекомендуется выполнять подключение и отключение в функциях, которые вызываются до и после каждого запроса. Это можно сделать с помощью декораторов `@app.before_request` и `@app.teardown_request`:

```python
from flask import Flask

app = Flask(__name__)

# Функция для подключения к базе данных
def get_db():
    conn = sqlite3.connect('example.db')
    conn.row_factory = sqlite3.Row # Возвращает результаты в виде словарей
    return conn

# Подключение к базе данных перед каждым запросом
@app.before_request
def before_request():
    g.db = get_db()

# Отключение от базы данных после каждого запроса
@app.teardown_request
def teardown_request(exception):
    if hasattr(g, 'db'):
        g.db.close()

# Пример использования базы данных в маршруте
@app.route('/')
def index():
    cursor = g.db.cursor()
    cursor.execute("SELECT * FROM users")
    users = cursor.fetchall()
    return render_template('index.html', users=users)
```

В этом примере мы создаем функцию `get_db()`, которая подключается к базе данных и устанавливает `row_factory` в `sqlite3.Row`, чтобы получать результаты в виде словарей. Декораторы `@app.before_request` и `@app.teardown_request` обеспечивают подключение и отключение от базы данных для каждого запроса. В маршруте `index()` мы получаем данные из таблицы `users` и передаем их в шаблон `index.html`.

### Заключение

В данной статье мы рассмотрели базовые операции по работе с базой данных SQLite в Flask. Подробная информация о модуле `sqlite3` доступна в [официальной документации](https://docs.python.org/3/library/sqlite3.html). Для работы с другими базами данных, такими как PostgreSQL, MySQL, рекомендуется использовать SQLAlchemy, который предоставляет более высокий уровень абстракции и дополнительные возможности. 
