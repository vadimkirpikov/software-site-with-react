## Подзапросы в PostgreSQL

Подзапрос — это SQL-запрос, вложенный внутрь другого SQL-запроса. В PostgreSQL подзапросы можно использовать в различных частях запроса, например, в `WHERE`, `HAVING`, `FROM` и других. Подзапросы выполняются "изнутри наружу": сначала выполняется самый внутренний подзапрос, затем его результат используется для выполнения следующего по уровню вложенности запроса и так далее.

**Типы подзапросов:**

* **Скалярные подзапросы** возвращают одно значение (одно столбец и одну строку).
* **Строчные подзапросы** возвращают одну строку с одним или несколькими столбцами.
* **Многострочные подзапросы** возвращают таблицу (несколько строк и столбцов).

### Скалярные подзапросы

Скалярные подзапросы используются, когда нужно получить одно значение для сравнения с основным запросом. 

**Пример:** Найти всех сотрудников, зарплата которых выше средней по компании:

```sql
SELECT *
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

**Пояснение:**

1. Внутренний подзапрос `(SELECT AVG(salary) FROM employees)` вычисляет среднюю зарплату по всем сотрудникам.
2. Внешний запрос выбирает всех сотрудников, у которых зарплата больше значения, возвращенного внутренним подзапросом.

### Строчные подзапросы

Строчные подзапросы используются с операторами сравнения, которые работают с одной строкой, например, `=`, `>`, `<`, `>=`, `<=`, `<>`.

**Пример:** Найти отдел с максимальной средней зарплатой:

```sql
SELECT *
FROM departments
WHERE dept_id = (SELECT dept_id
                  FROM employees
                  GROUP BY dept_id
                  ORDER BY AVG(salary) DESC
                  LIMIT 1);
```

**Пояснение:**

1. Внутренний подзапрос находит `dept_id` отдела с максимальной средней зарплатой, сортируя по `AVG(salary)` в порядке убывания и ограничивая результат одной строкой.
2. Внешний запрос выбирает все данные отдела с `dept_id`, равным результату внутреннего подзапроса.

### Многострочные подзапросы

Многострочные подзапросы используются с операторами, работающими с множеством значений, такими как `IN`, `NOT IN`, `ANY`, `ALL`, `EXISTS`, `NOT EXISTS`.

**Пример:** Найти всех сотрудников, которые работают в отделе "Sales":

```sql
SELECT *
FROM employees
WHERE dept_id IN (SELECT dept_id
                  FROM departments
                  WHERE dept_name = 'Sales');
```

**Пояснение:**

1. Внутренний подзапрос выбирает `dept_id` отдела с названием "Sales".
2. Внешний запрос выбирает всех сотрудников, `dept_id` которых присутствует в результате внутреннего подзапроса.

### Оператор EXISTS

Оператор `EXISTS` проверяет, возвращает ли подзапрос хотя бы одну строку. 

**Пример:** Проверить, есть ли сотрудники в отделе "Marketing":

```sql
SELECT EXISTS (SELECT 1 
               FROM employees 
               WHERE dept_id = (SELECT dept_id 
                               FROM departments 
                               WHERE dept_name = 'Marketing'));
```

**Пояснение:**

1. Внутренний подзапрос выбирает `dept_id` отдела с названием "Marketing".
2. Второй подзапрос проверяет, есть ли сотрудники с таким `dept_id`, и возвращает `1`, если найдет хотя бы одного.
3. `EXISTS` возвращает `true`, если второй подзапрос вернул хотя бы одну строку (т.е. есть сотрудники в отделе), иначе `false`.

### Оператор ANY/ALL

Операторы `ANY` и `ALL` используются для сравнения значения с каждым элементом в списке, возвращаемом подзапросом.

**Пример:** Найти всех сотрудников, зарплата которых больше зарплаты любого сотрудника в отделе "IT":

```sql
SELECT *
FROM employees
WHERE salary > ANY (SELECT salary
                  FROM employees
                  WHERE dept_id = (SELECT dept_id
                                  FROM departments
                                  WHERE dept_name = 'IT'));
```

**Пояснение:**

1. Внутренний подзапрос выбирает зарплаты всех сотрудников из отдела "IT".
2. `ANY` проверяет, больше ли зарплата сотрудника из основного запроса, чем хотя бы одна зарплата из списка, возвращенного подзапросом.

###  Замечания

* Чрезмерное использование подзапросов может снизить производительность запросов.
* PostgreSQL предлагает альтернативные способы написания запросов, которые могут быть более эффективными, чем использование подзапросов. Например, использование операторов `JOIN` или `WITH`.
* Важно анализировать планы выполнения запросов, чтобы убедиться в их эффективности. 

Это базовая информация о подзапросах в PostgreSQL. Более подробную информацию о конкретных типах подзапросов, их синтаксисе и особенностях использования можно найти в официальной документации PostgreSQL. 
