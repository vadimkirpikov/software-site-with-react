## Рекурсия в функциях PostgreSQL

Рекурсия – это мощный инструмент в программировании, позволяющий функции вызывать саму себя. PostgreSQL, начиная с ранних версий, поддерживает рекурсивные функции, предоставляя широкие возможности для обработки древовидных структур данных, иерархических отношений и решения других задач, где требуется многократное повторение операций.

### Принцип работы рекурсивной функции

Рекурсивная функция состоит из двух основных частей:

1. **Базовый случай (условие выхода):** Определяет, когда рекурсия должна прекратиться. Без базового случая рекурсия будет продолжаться бесконечно, что приведёт к ошибке.
2. **Рекурсивный шаг:** Вызов функцией самой себя с модифицированными аргументами, приближающими функцию к базовому случаю.

### Создание рекурсивной функции в PostgreSQL

Для создания рекурсивной функции в PostgreSQL используется ключевое слово `WITH RECURSIVE`. Внутри блока `WITH RECURSIVE` определяется рекурсивное отношение (CTE), которое затем используется в основном запросе.

**Пример:**

Предположим, у нас есть таблица "employees" с информацией о сотрудниках:

| id | name | manager_id |
|---|---|---|
| 1 | Иван | NULL |
| 2 | Петр | 1 |
| 3 | Сидор | 1 |
| 4 | Анна | 2 |
| 5 | Мария | 2 |

Задача: получить список всех подчинённых для заданного менеджера (включая подчинённых подчинённых и т.д.).

```sql
CREATE FUNCTION get_all_subordinates(manager_id INT)
RETURNS TABLE (employee_id INT, employee_name TEXT)
LANGUAGE sql
AS $$
  WITH RECURSIVE subordinates AS (
    -- Базовый случай: выбрать непосредственных подчинённых менеджера
    SELECT id, name
    FROM employees
    WHERE manager_id = manager_id

    UNION ALL

    -- Рекурсивный шаг: выбрать подчинённых для каждого подчинённого, найденного на предыдущем шаге
    SELECT e.id, e.name
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
  )
  SELECT * FROM subordinates;
$$;
```

**Пояснения:**

1. Создаем функцию `get_all_subordinates`, которая принимает `manager_id` в качестве аргумента и возвращает таблицу с `employee_id` и `employee_name`.
2. Внутри функции используем `WITH RECURSIVE`, чтобы определить рекурсивное отношение `subordinates`.
3. В базовом случае выбираем всех сотрудников, у которых `manager_id` равен переданному в функцию значению.
4. В рекурсивном шаге соединяем таблицу `employees` с отношением `subordinates`, чтобы найти подчинённых для каждого найденного на предыдущем шаге сотрудника.
5. Оператор `UNION ALL` объединяет результаты базового случая и рекурсивного шага.
6. Наконец, функция возвращает все строки из рекурсивного отношения `subordinates`.

**Вызов функции:**

```sql
SELECT * FROM get_all_subordinates(1);
```

**Результат:**

| employee_id | employee_name |
|---|---|
| 2 | Петр |
| 3 | Сидор |
| 4 | Анна |
| 5 | Мария |

### Преимущества и недостатки рекурсии

**Преимущества:**

* **Элегантность и лаконичность:** Рекурсия позволяет решать задачи, связанные с иерархическими структурами, более изящно и с меньшим количеством кода по сравнению с итеративным подходом.
* **Понятность:**  Код рекурсивных функций часто более понятен и лёгок для восприятия, особенно при работе с древовидными структурами.

**Недостатки:**

* **Сложность отладки:** Отладка рекурсивных функций может быть сложнее по сравнению с итеративными функциями.
* **Производительность:** В некоторых случаях рекурсивные функции могут работать медленнее, чем итеративные аналоги, особенно при обработке больших объемов данных. 

### Заключение

Рекурсия в функциях PostgreSQL - мощный инструмент для работы с иерархическими данными. Понимание принципов работы рекурсии и умение создавать рекурсивные функции позволят вам решать широкий спектр задач баз данных PostgreSQL более эффективно. 
