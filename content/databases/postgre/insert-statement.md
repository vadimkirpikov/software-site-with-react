## Вставка данных (INSERT INTO) в PostgreSQL

Оператор `INSERT INTO` используется для добавления новых строк (записей) в таблицу. В этой статье мы рассмотрим различные способы использования `INSERT INTO`, начиная с основ и заканчивая более сложными сценариями.

### Базовый синтаксис

Самая простая форма оператора `INSERT INTO` выглядит следующим образом:

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...)
VALUES (значение1, значение2, ...);
```

Давайте разберем этот синтаксис:

* **`INSERT INTO`**: Ключевые слова, указывающие на операцию вставки данных.
* **`имя_таблицы`**: Имя таблицы, в которую нужно вставить данные.
* **`(столбец1, столбец2, ...)`**: Список столбцов, в которые будут вставлены значения. Порядок столбцов не обязан совпадать с порядком столбцов в таблице.
* **`VALUES`**: Ключевое слово, указывающее на начало списка значений.
* **`(значение1, значение2, ...)`**: Список значений, соответствующих указанным столбцам. 

**Пример:**

Предположим, у нас есть таблица `users` со следующей структурой:

| Столбец | Тип данных |
|---|---|
| id | SERIAL |
| name | VARCHAR(255) |
| email | VARCHAR(255) |
| created_at | TIMESTAMP WITH TIME ZONE |

Чтобы добавить нового пользователя в таблицу `users`, выполните следующий запрос:

```sql
-- Вставка новой строки в таблицу users
INSERT INTO users (name, email, created_at)
VALUES ('Иван Иванов', 'ivan.ivanov@example.com', NOW());
```

В этом примере:

* Мы вставляем данные в столбцы `name`, `email` и `created_at`.
* Значение `NOW()` возвращает текущую дату и время, которые будут записаны в столбец `created_at`.
* Столбец `id` имеет тип данных `SERIAL`, поэтому PostgreSQL автоматически сгенерирует уникальный идентификатор для новой строки.

### Вставка данных во все столбцы

Если вы хотите вставить данные во все столбцы таблицы, можно использовать сокращенный синтаксис, не указывая список столбцов:

```sql
INSERT INTO имя_таблицы
VALUES (значение1, значение2, ...);
```

**Пример:**

```sql
-- Вставка новой строки в таблицу users, указывая значения для всех столбцов
INSERT INTO users
VALUES (DEFAULT, 'Петр Сидоров', 'petr.sidorov@example.com', NOW());
```

В этом примере мы не указываем столбец `id`, но вместо этого используем ключевое слово `DEFAULT`, чтобы PostgreSQL автоматически сгенерировал значение для этого столбца.

### Вставка нескольких строк

Для вставки нескольких строк за один запрос можно использовать следующий синтаксис:

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...)
VALUES
  (значение1_1, значение1_2, ...),
  (значение2_1, значение2_2, ...),
  ...;
```

**Пример:**

```sql
-- Вставка двух новых строк в таблицу users
INSERT INTO users (name, email, created_at)
VALUES
  ('Мария Петрова', 'maria.petrova@example.com', NOW()),
  ('Алексей Иванов', 'alexey.ivanov@example.com', NOW());
```

### Вставка данных из другой таблицы

PostgreSQL позволяет вставлять данные в таблицу из другой таблицы, используя подзапрос с оператором `SELECT`.

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...)
SELECT столбец1, столбец2, ...
FROM другая_таблица
WHERE условие;
```

**Пример:**

Предположим, у нас есть таблица `customers` со столбцами `id`, `name` и `email`, и мы хотим скопировать всех клиентов из Москвы в таблицу `moscow_customers` (которая имеет ту же структуру, что и `customers`).

```sql
-- Создание таблицы moscow_customers
CREATE TABLE moscow_customers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255)
);

-- Вставка данных из таблицы customers в таблицу moscow_customers
INSERT INTO moscow_customers (name, email)
SELECT name, email
FROM customers
WHERE city = 'Москва';
```

### Возвращение вставленных данных

По умолчанию оператор `INSERT` не возвращает данные о вставленных строках. Однако можно использовать предложение `RETURNING`, чтобы получить значения вставленных строк.

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...)
VALUES (значение1, значение2, ...)
RETURNING столбец1, столбец2, ...;
```

**Пример:**

```sql
-- Вставка новой строки и возврат id и created_at
INSERT INTO users (name, email, created_at)
VALUES ('Анна Сидорова', 'anna.sidorova@example.com', NOW())
RETURNING id, created_at;
```

### Обработка ошибок

При вставке данных могут возникнуть ошибки, например, нарушение ограничений целостности или попытка вставки дублирующихся значений. В PostgreSQL можно использовать блок `ON CONFLICT`, чтобы определить поведение при возникновении конфликтов.

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...)
VALUES (значение1, значение2, ...)
ON CONFLICT (столбец_уникальности)
DO UPDATE SET столбец1 = excluded.столбец1, ...
WHERE условие;
```

**Пример:**

```sql
-- Вставка новой строки, обновление email, если пользователь с таким id уже существует
INSERT INTO users (id, name, email)
VALUES (100, 'Иван Иванов', 'new.email@example.com')
ON CONFLICT (id)
DO UPDATE SET email = excluded.email;
```

В этом примере:

* `excluded` - специальная таблица, содержащая значения, которые пытались вставить.
* Если в таблице `users` уже существует пользователь с `id = 100`, его `email` будет обновлен значением из столбца `email` таблицы `excluded`.

Это базовые принципы использования `INSERT INTO` в PostgreSQL. Существуют и более сложные сценарии, например, использование CTE (Common Table Expressions) или генерация данных для вставки с помощью функций. Подробнее об этих возможностях можно узнать в документации PostgreSQL.
