## Подзапросы в MySQL

Подзапрос (subquery) - это запрос, вложенный внутрь другого запроса SQL. Он позволяет получать данные из одной или нескольких таблиц и использовать их в основном запросе для фильтрации, сортировки или выполнения других операций.

**Типы подзапросов:**

* **Скалярные подзапросы:** возвращают одно значение (одна строка и один столбец).
* **Строчные подзапросы:** возвращают одну строку с несколькими столбцами.
* **Подзапросы-таблицы:** возвращают несколько строк и столбцов, действуя как виртуальная таблица.

### Использование подзапросов

Подзапросы могут использоваться в различных частях SQL-запроса, включая:

* **Внутри `WHERE`:** для фильтрации данных на основе результатов подзапроса.
* **Внутри `FROM`:** для создания виртуальной таблицы из результатов подзапроса.
* **Внутри `HAVING`:** для фильтрации сгруппированных данных на основе результатов подзапроса.
* **Внутри списков `SELECT`:** для добавления данных из подзапроса в результирующий набор.

### Операторы сравнения с подзапросами

* **`=` (равно):** Возвращает TRUE, если результат подзапроса равен указанному значению.
* **`<>` (не равно), `!=`:** Возвращает TRUE, если результат подзапроса не равен указанному значению.
* **`>` (больше), `<` (меньше), `>=` (больше или равно), `<=` (меньше или равно):** Сравнивает результат подзапроса с указанным значением.
* **`IN`:** Возвращает TRUE, если значение находится в списке, возвращаемом подзапросом.
* **`NOT IN`:** Возвращает TRUE, если значение не находится в списке, возвращаемом подзапросом.
* **`EXISTS`:** Возвращает TRUE, если подзапрос возвращает хотя бы одну строку.
* **`NOT EXISTS`:** Возвращает TRUE, если подзапрос не возвращает ни одной строки.

### Примеры использования подзапросов

**Пример 1: Выбрать сотрудников с зарплатой выше средней**

```sql
-- Выбираем имя и зарплату сотрудников
SELECT employee_name, salary
-- Из таблицы сотрудников
FROM employees
-- Где зарплата больше средней зарплаты всех сотрудников
WHERE salary > (SELECT AVG(salary) FROM employees); 
```

В этом примере подзапрос `(SELECT AVG(salary) FROM employees)` вычисляет среднюю зарплату всех сотрудников. Основной запрос затем выбирает сотрудников, чья зарплата больше этой средней.

**Пример 2: Выбрать заказы, сделанные в тот же день, что и заказ с максимальным номером**

```sql
-- Выбираем все заказы
SELECT *
-- Из таблицы заказов
FROM orders
-- Где дата заказа равна дате заказа с максимальным номером заказа
WHERE order_date = (SELECT order_date FROM orders ORDER BY order_id DESC LIMIT 1);
```

В этом примере подзапрос `(SELECT order_date FROM orders ORDER BY order_id DESC LIMIT 1)` находит дату заказа с максимальным номером заказа. Основной запрос выбирает все заказы, сделанные в эту дату.

**Пример 3: Выбрать клиентов, которые сделали заказ на определенный товар**

```sql
-- Выбираем имя клиента
SELECT customer_name
-- Из таблицы клиентов
FROM customers
-- Где id клиента есть в списке id клиентов, которые сделали заказ на товар с id = 1
WHERE customer_id IN (SELECT customer_id FROM orders WHERE product_id = 1);
```

В этом примере подзапрос `(SELECT customer_id FROM orders WHERE product_id = 1)` выбирает id клиентов, которые сделали заказ на товар с id = 1. Основной запрос выбирает имена клиентов, чьи id находятся в этом списке.

### Коррелированные подзапросы

Коррелированный подзапрос - это подзапрос, который зависит от значений во внешнем запросе. Он выполняется один раз для каждой строки, возвращаемой внешним запросом.

**Пример:**

```sql
-- Выбираем имя и зарплату сотрудников
SELECT employee_name, salary
-- Из таблицы сотрудников
FROM employees e1
-- Где зарплата больше средней зарплаты сотрудников в том же отделе
WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e1.department_id);
```

В этом примере подзапрос `(SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e1.department_id)` вычисляет среднюю зарплату сотрудников в том же отделе, что и текущий сотрудник из внешнего запроса. Это достигается путем сравнения `e2.department_id` (id отдела во внутреннем запросе) с `e1.department_id` (id отдела во внешнем запросе).

### Преимущества использования подзапросов

* **Повышение читаемости кода:** Подзапросы позволяют разбить сложную логику на более мелкие и понятные части.
* **Уменьшение дублирования кода:** Подзапросы можно использовать вместо повторения одинакового кода в разных частях запроса.
* **Повышение эффективности:** В некоторых случаях подзапросы могут быть более эффективными, чем альтернативные методы.

### Недостатки использования подзапросов

* **Усложнение запросов:** Подзапросы могут усложнить запросы и сделать их трудными для понимания.
* **Снижение производительности:** В некоторых случаях подзапросы могут снизить производительность, особенно если они используются неправильно.

### Рекомендации по использованию подзапросов

* **Используйте подзапросы только при необходимости:** Если есть более простой способ достичь желаемого результата, не используйте подзапросы.
* **Старайтесь делать подзапросы как можно более простыми:** Сложные подзапросы могут быть трудными для понимания и отладки.
* **Индексируйте столбцы, используемые в подзапросах:** Это может повысить производительность.
* **Используйте `EXPLAIN`, чтобы проанализировать производительность подзапросов.**

Подзапросы - мощный инструмент, который может быть использован для решения широкого круга задач в MySQL. Понимание того, как использовать подзапросы эффективно, может сделать ваш код более читаемым, лаконичным и производительным. 
