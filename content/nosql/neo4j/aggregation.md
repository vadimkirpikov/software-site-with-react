## Использование агрегатных функций

Агрегатные функции в Neo4j позволяют вам сводить данные из множества узлов и ребер в единое значение.  Это мощный инструмент для анализа данных и получения ответов на сложные вопросы. 

### Базовые агрегатные функции

Neo4j предоставляет следующие базовые агрегатные функции:

| Функция | Описание |
|---|---|
| `count()` | Возвращает количество элементов в наборе данных. |
| `sum()` | Возвращает сумму числовых значений в наборе данных. |
| `avg()` | Возвращает среднее арифметическое числовых значений в наборе данных. |
| `min()` | Возвращает минимальное значение в наборе данных. |
| `max()` | Возвращает максимальное значение в наборе данных. |

**Пример:**

Представьте, что у вас есть база данных о книгах и их авторах. 

```cypher
CREATE (a:Author {name: "Джон Стейнбек"})
CREATE (b:Author {name: "Эрнест Хемингуэй"})
CREATE (c:Author {name: "Фрэнсис Скотт Фицджеральд"})
CREATE (book1:Book {title: "Гроздья гнева", year: 1939})
CREATE (book2:Book {title: "Старик и море", year: 1952})
CREATE (book3:Book {title: "Великий Гэтсби", year: 1925})
CREATE (a)-[:WROTE]->(book1)
CREATE (b)-[:WROTE]->(book2)
CREATE (c)-[:WROTE]->(book3)
```

Вы можете использовать функцию `count()` для подсчета количества книг:

```cypher
MATCH (b:Book)
RETURN count(b) AS total_books;
```

**Результат:**

```
total_books
-----------
3
```

### Агрегация с использованием `WITH`

Для более сложных запросов, включающих несколько агрегатных функций, вы можете использовать ключевое слово `WITH`.  `WITH` позволяет вам сохранить результаты одной операции для дальнейшей обработки в следующей.

**Пример:**

Найдите средний год публикации книг каждого автора.

```cypher
MATCH (a:Author)-[:WROTE]->(b:Book)
WITH a, avg(b.year) AS average_year
RETURN a.name, average_year;
```

**Результат:**

```
a.name           | average_year
-----------------|-------------
Джон Стейнбек    | 1939
Эрнест Хемингуэй | 1952
Фрэнсис Скотт Фицджеральд | 1925
```

### Агрегация по группам

Используйте `COLLECT` для группировки данных и применения агрегатных функций к каждой группе.

**Пример:**

Найдите количество книг, написанных каждым автором.

```cypher
MATCH (a:Author)-[:WROTE]->(b:Book)
WITH a, collect(b) AS books
RETURN a.name, size(books) AS books_count
ORDER BY books_count DESC;
```

**Результат:**

```
a.name             | books_count
-------------------|-------------
Джон Стейнбек    | 1
Эрнест Хемингуэй | 1
Фрэнсис Скотт Фицджеральд | 1
```

### Агрегация с использованием `CASE`

`CASE` позволяет вам выполнять различные действия в зависимости от значения.  Сочетание `CASE` с агрегатными функциями позволяет создавать сложные и гибкие запросы.

**Пример:**

Найдите количество книг, написанных до и после 1940 года.

```cypher
MATCH (b:Book)
WITH b, CASE WHEN b.year < 1940 THEN "До 1940" ELSE "После 1940" END AS year_group
RETURN year_group, count(b) AS book_count;
```

**Результат:**

```
year_group   | book_count
-------------|-------------
До 1940    | 1
После 1940  | 2
```

### Агрегация с использованием `UNWIND`

`UNWIND` используется для разворачивания списков и позволяет вам применить агрегатные функции к элементам списка.

**Пример:**

Найдите общее количество слов во всех названиях книг.

```cypher
MATCH (b:Book)
WITH b, split(b.title, ' ') AS words
UNWIND words AS word
RETURN count(word) AS total_words;
```

**Результат:**

```
total_words
-----------
12
```

### Дополнительные замечания

* Агрегатные функции могут использоваться в различных комбинациях и вместе с другими операторами Cypher.
* Изучите документацию Neo4j для полного списка доступных агрегатных функций и их параметров.
* Используйте агрегатные функции для анализа больших объемов данных и получения ценной информации.

### Заключение

Использование агрегатных функций в Neo4j позволяет вам легко анализировать и получать ценную информацию из ваших данных.  Экспериментируйте с различными функциями и комбинациями для решения ваших задач.  В следующих разделах вы познакомитесь с более сложными и продвинутыми вариантами применения агрегатных функций. 
