## Объединения и сложные запросы

В предыдущих разделах мы рассмотрели основы работы с Neo4j, включая создание узлов, связей и выполнение простых запросов. Однако для решения более сложных задач,  необходимы более мощные инструменты, которые позволяют объединять результаты нескольких запросов и создавать сложные условия поиска. 

В этом разделе мы рассмотрим ключевые концепции объединений (joins) и  сложных запросов, которые помогут вам эффективно извлекать информацию из вашей графовой базы данных.

### Объединения

Объединение (JOIN) в Neo4j - это механизм, который позволяет комбинировать результаты нескольких запросов, основываясь на общих узлах или связях. В отличие от реляционных баз данных, Neo4j не использует ключевые поля для объединения данных, а опирается на отношения между узлами и связями.

Существуют два основных типа объединений в Neo4j:

* **MATCH**
* **WITH**

#### MATCH

Объединение **MATCH** позволяет объединять результаты нескольких запросов, основываясь на совпадающих узлах или связях. 

**Пример:**

Допустим, у нас есть граф, содержащий информацию о людях и их связях с различными городами. 

```cypher
// Создаем узлы для людей и городов
CREATE (p:Person {name: 'Alice'}), (p2:Person {name: 'Bob'}), 
       (c1:City {name: 'London'}), (c2:City {name: 'Paris'});

// Создаем связи между людьми и городами
CREATE (p)-[:LIVES_IN]->(c1), (p2)-[:VISITED]->(c2);
```

Мы хотим найти всех людей, которые живут в Лондоне и были в Париже.

```cypher
MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'London'}), 
      (p)-[:VISITED]->(c2:City {name: 'Paris'})
RETURN p.name, c.name, c2.name;
```

В этом запросе мы используем два выражения **MATCH** для поиска людей, которые живут в Лондоне и тех же самых людей, которые посещали Париж. Совпадение достигается за счет использования одного и того же имени переменной `p` для человека в обоих выражениях **MATCH**.

#### WITH

Объединение **WITH** позволяет сохранять промежуточные результаты запроса и использовать их в следующих запросах.

**Пример:**

Допустим, мы хотим найти всех людей, которые живут в Лондоне и у которых есть хотя бы один друг.

```cypher
MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'London'})
WITH p // Сохраняем информацию о людях, которые живут в Лондоне
MATCH (p)-[:FRIEND_OF]->(f:Person) 
RETURN p.name, f.name;
```

В этом запросе мы сначала находим всех людей, которые живут в Лондоне. Затем мы используем ключевое слово **WITH** для сохранения информации о найденных людях. В следующем запросе мы используем сохраненные переменные `p` для поиска их друзей.

### Сложные запросы

Сложные запросы позволяют создавать  условия поиска, которые  могут включать:

* **Логические операторы**: AND, OR, NOT
* **Сравнительные операторы**:  =, !=, >, <, >=, <=
* **Вложенные запросы**

#### Логические операторы

Логические операторы позволяют комбинировать несколько условий поиска.

* **AND**: Истина, если все условия истинны
* **OR**: Истина, если хотя бы одно условие истинно
* **NOT**: Отрицание условия

**Пример:**

Найдем всех людей, которые живут в Лондоне и у которых нет друзей в Париже:

```cypher
MATCH (p:Person)-[:LIVES_IN]->(c:City {name: 'London'})
WHERE NOT (p)-[:FRIEND_OF]->(f:Person)-[:LIVES_IN]->(c2:City {name: 'Paris'})
RETURN p.name;
```

В этом запросе мы используем **NOT** для поиска людей, у которых нет друзей в Париже. 

#### Сравнительные операторы

Сравнительные операторы позволяют  сравнивать значения.

**Пример:**

Найдем всех людей, которые старше 30 лет:

```cypher
MATCH (p:Person)
WHERE p.age > 30
RETURN p.name;
```

#### Вложенные запросы

Вложенные запросы позволяют  выполнять  запросы внутри других запросов.

**Пример:**

Найдем всех людей, которые имеют  друзей, которые старше 40 лет:

```cypher
MATCH (p:Person)
WHERE (p)-[:FRIEND_OF]->(f:Person) WHERE f.age > 40
RETURN p.name;
```

В этом запросе мы используем вложенный запрос  **WHERE (p)-[:FRIEND_OF]->(f:Person) WHERE f.age > 40** для поиска друзей, которые старше 40 лет.

### Заключение

Объединения и сложные запросы предоставляют вам широкие возможности для анализа и извлечения информации из вашего графового  модели. 

Помните, что умение строить эффективные запросы  является ключевым навыком для работы с Neo4j. 
