## Однострочные функции

В Kotlin функции могут быть объявлены максимально кратко, в одну строку, если их тело содержит всего одно выражение. Это делает код более лаконичным и удобным для чтения.

**Синтаксис:**

```kotlin
fun имяФункции(параметры): ТипВозвращаемогоЗначения = выражение
```

**Пример:**

```kotlin
fun square(x: Int): Int = x * x  // Возвращает квадрат числа

fun main() {
    val result = square(5)
    println(result) // Вывод: 25
}
```

В этом примере функция `square` принимает один аргумент `x` типа `Int` и возвращает его квадрат, вычисляемый в единственном выражении. 

**Преимущества однострочных функций:**

- **Краткость и читаемость:** Код становится короче и проще для восприятия.
- **Улучшение структуры кода:** Короткие функции легче понимать и использовать повторно.

## Локальные функции

Kotlin позволяет определять функции внутри других функций. Такие функции называются локальными. 

**Преимущества локальных функций:**

- **Инкапсуляция:** Локальные функции скрыты от внешнего кода, что улучшает структуру программы.
- **Повторное использование:** Локальные функции могут использоваться для многократного выполнения повторяющихся действий внутри другой функции.

**Пример:**

```kotlin
fun calculateTotal(prices: List<Double>): Double {
    
    fun calculateDiscount(price: Double): Double = price * 0.1

    var total = 0.0
    for (price in prices) {
        val discount = calculateDiscount(price) // Вызов локальной функции
        total += price - discount
    }
    return total
}

fun main() {
    val prices = listOf(10.0, 20.0, 30.0)
    val total = calculateTotal(prices)
    println(total) // Вывод: 54.0
}
```

В этом примере функция `calculateDiscount` определена внутри функции `calculateTotal`. Она используется для вычисления скидки для каждой цены в списке. Локальная функция доступна только внутри `calculateTotal`, что обеспечивает инкапсуляцию и повышает читаемость кода.

## Комбинирование однострочных и локальных функций

Однострочные функции могут быть объявлены и внутри других функций, сочетая преимущества обоих подходов.

**Пример:**

```kotlin
fun processList(numbers: List<Int>): List<Int> {

    fun isEven(number: Int): Boolean = number % 2 == 0  // Однострочная локальная функция

    val evenNumbers = mutableListOf<Int>()
    for (number in numbers) {
        if (isEven(number)) {  // Вызов локальной функции
            evenNumbers.add(number)
        }
    }
    return evenNumbers
}

fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    val evenNumbers = processList(numbers)
    println(evenNumbers) // Вывод: [2, 4]
}
```

В этом примере однострочная локальная функция `isEven` проверяет, является ли число четным. Она используется внутри функции `processList` для фильтрации списка чисел.

Использование однострочных и локальных функций позволяет создавать более лаконичный, читаемый и организованный код на Kotlin.
