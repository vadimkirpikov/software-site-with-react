## Анонимные функции и лямбда-выражения в Kotlin

Kotlin, как современный язык программирования, предоставляет разработчикам мощные инструменты для работы с функциями высшего порядка. 
 Одними из таких инструментов являются анонимные функции и лямбда-выражения, которые позволяют писать более лаконичный и выразительный код.

**Анонимные функции** представляют собой функции, не объявленные с определенным именем. Они определяются в месте их использования и могут быть переданы в качестве аргументов другим функциям.

**Лямбда-выражения** – это краткая форма записи анонимных функций, которая позволяет сделать код еще более компактным.

### Создание анонимной функции

Синтаксис анонимной функции в Kotlin выглядит следующим образом:

```kotlin
fun(аргументы: ТипыАргументов): ТипВозвращаемогоЗначения {
    // Тело функции
}
```

Рассмотрим пример создания анонимной функции, которая принимает два целочисленных аргумента и возвращает их сумму:

```kotlin
fun main() {
    val sum = fun(a: Int, b: Int): Int {
        return a + b
    }
    
    val result = sum(5, 3) // result = 8
    println(result) 
}
```

В данном примере мы создали анонимную функцию, присвоили ее переменной `sum`, а затем вызвали ее с аргументами `5` и `3`, сохранив результат в переменной `result`.

### Создание лямбда-выражения

Лямбда-выражения в Kotlin имеют более краткий синтаксис по сравнению с анонимными функциями. Синтаксис лямбда-выражения:

```kotlin
{ аргументы: ТипыАргументов -> выражение }
```

или

```kotlin
{ аргументы: ТипыАргументов ->
    // Тело лямбда-выражения
}
```

Давайте перепишем предыдущий пример с использованием лямбда-выражения:

```kotlin
fun main() {
    val sum = { a: Int, b: Int -> a + b }
    
    val result = sum(5, 3) // result = 8
    println(result) 
}
```

В этом примере мы создали лямбда-выражение, которое принимает два аргумента `a` и `b` и возвращает их сумму. Как видите, лямбда-выражение позволяет записать ту же логику более компактно.

### Использование анонимных функций и лямбда-выражений

Анонимные функции и лямбда-выражения широко используются в Kotlin для работы с функциями высшего порядка, такими как `filter`, `map`, `forEach` и др. 

#### Пример использования с `filter`

Функция `filter` принимает предикативную функцию (функцию, возвращающую `Boolean`) в качестве аргумента и возвращает новый список, содержащий только те элементы, для которых предикат вернул `true`.

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5, 6)
    
    // Фильтрация четных чисел с помощью анонимной функции
    val evenNumbers = numbers.filter(fun(number: Int): Boolean {
        return number % 2 == 0
    })
    
    // Фильтрация нечетных чисел с помощью лямбда-выражения
    val oddNumbers = numbers.filter { number: Int -> number % 2 != 0 }
    
    println("Четные числа: $evenNumbers") // Вывод: [2, 4, 6]
    println("Нечетные числа: $oddNumbers") // Вывод: [1, 3, 5]
}
```

#### Пример использования с `map`

Функция `map` применяет переданную функцию к каждому элементу коллекции и возвращает новую коллекцию с результатами.

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    // Умножение каждого элемента на 2 с помощью анонимной функции
    val doubledNumbers = numbers.map(fun(number: Int): Int {
        return number * 2
    })
    
    // Возведение каждого элемента в квадрат с помощью лямбда-выражения
    val squaredNumbers = numbers.map { number: Int -> number * number }
    
    println("Удвоенные числа: $doubledNumbers") // Вывод: [2, 4, 6, 8, 10]
    println("Квадраты чисел: $squaredNumbers") // Вывод: [1, 4, 9, 16, 25]
}
```

#### Пример использования с `forEach`

Функция `forEach` выполняет переданную функцию для каждого элемента коллекции.

```kotlin
fun main() {
    val names = listOf("Алиса", "Боб", "Чарли")
    
    // Вывод приветствия для каждого имени с помощью лямбда-выражения
    names.forEach { name: String -> println("Привет, $name!") }
}
```

### Вывод

Анонимные функции и лямбда-выражения – это мощные инструменты, которые делают код Kotlin более лаконичным, выразительным и удобным для чтения. Использование этих инструментов позволяет писать код в функциональном стиле, что особенно полезно при работе с коллекциями и другими структурами данных. 
