## Отмена выполнения корутин

Корутины в Kotlin предоставляют мощный механизм для асинхронного программирования, но, как и любые другие асинхронные операции, иногда их выполнение нужно отменить. 

Представим ситуацию: пользователь инициирует загрузку большого файла, но потом передумывает. В таком случае важно иметь возможность остановить загрузку, чтобы не тратить ресурсы устройства. 

Kotlin предоставляет несколько способов отмены выполнения корутин:

**1. Использование `Job`**:

Каждый раз, когда вы запускаете корутину, она возвращает объект `Job`.  Этот объект можно использовать для управления жизненным циклом корутины, в том числе и для ее отмены. 

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch { 
        repeat(1000) { i ->
            println("Job: $i")
            delay(500L)
        }
    }
    delay(1300L) // ждем 1300 мс
    println("Отменяем job...")
    job.cancel() // отменяем корутину
    job.join() // ожидаем завершения корутины
    println("main: выполнение завершено")
}
```

В этом примере мы запускаем корутину, которая выводит числа с задержкой. Через 1300 миллисекунд мы вызываем метод `cancel()` для объекта `job`, что инициирует отмену корутины. Метод `join()` используется для ожидания завершения корутины.

**2. Проверка состояния отмены**:

Внутри корутины можно проверить, была ли она отменена, используя свойства `isActive` или `isCancelled` объекта `CoroutineContext`. Также можно использовать функцию `ensureActive()`, которая выбрасывает исключение `CancellationException`, если корутина была отменена. 

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        try {
            repeat(1000) { i ->
                println("Job: $i")
                ensureActive() // проверяем, не была ли корутина отменена
                delay(500L)
            }
        } catch (e: CancellationException) {
            println("Корутина отменена")
        } finally {
            println("Блок finally")
        }
    }
    delay(1300L) 
    println("Отменяем job...")
    job.cancel()
    job.join() 
    println("main: выполнение завершено")
}
```

В этом примере мы используем `ensureActive()` внутри цикла. Если корутина будет отменена, то `ensureActive()` выбросит исключение, которое будет обработано в блоке `catch`. 

**3. Обработка `CancellationException`:**

Когда корутина отменяется, выбрасывается исключение `CancellationException`. Вы можете перехватывать это исключение внутри корутины и выполнять необходимые действия, например, освобождать ресурсы. Важно помнить, что `CancellationException` считается нормальным способом завершения корутины, поэтому не стоит паниковать, если вы его перехватываете.

**4. Отмена по причине:**

Вы можете указать причину отмены, передав объект `CancellationException` в качестве аргумента методу `cancel()`. Это может быть полезно для передачи дополнительной информации о причине отмены.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        try {
            repeat(1000) { i ->
                println("Job: $i")
                delay(500L)
            }
        } catch (e: CancellationException) {
            println("Корутина отменена: ${e.message}")
        }
    }
    delay(1300L)
    println("Отменяем job...")
    job.cancel(CancellationException("Время вышло!"))
    job.join()
    println("main: выполнение завершено")
}
```

В этом примере мы передаем сообщение "Время вышло!" в конструктор `CancellationException`. Это сообщение будет доступно в блоке `catch` внутри корутины.

**Важно**: Отмена корутины - это кооперативный механизм. Это означает, что корутина должна быть написана таким образом, чтобы она могла быть отменена.  Если корутина выполняет блокирующую операцию, которая не может быть прервана, то отмена не произойдет, пока эта операция не будет завершена.

В следующих разделах мы рассмотрим более сложные сценарии отмены корутин, такие как отмена родительских корутин и использование таймаутов.
