## Расширенные методы маршрутизации в Ktor

В этой статье мы рассмотрим расширенные методы маршрутизации, которые позволяют более гибко и точно определять обработчики для HTTP-запросов. Мы изучим параметры пути, заголовки и использование регулярных выражений для маршрутизации в Ktor.

### Параметры пути

Параметры пути – это именованные части URL-адреса, которые могут меняться.  Они позволяют извлекать информацию из самого URL и использовать ее в обработчике запроса.

**Пример:**

```kotlin
routing {
    get("/users/{id}") { // id - параметр пути
        val userId = call.parameters["id"] // Получаем значение параметра "id"
        call.respondText("Запрошен пользователь с ID: $userId")
    }
}
```

В этом примере `id` является параметром пути. Ktor автоматически извлекает значение этого параметра из URL и передает его в обработчик через `call.parameters`.

#### Типы данных параметров пути

По умолчанию параметры пути воспринимаются как строки. Однако, вы можете указать тип данных для параметра, используя двоеточие и имя типа:

```kotlin
routing {
    get("/items/{itemId: Int}") { // itemId - параметр пути типа Int
        val itemId = call.parameters["itemId"]?.toInt() ?: -1 // Безопасное получение значения
        // ...
    }
}
```

В этом случае, Ktor попытается преобразовать значение параметра `itemId` к типу `Int`. Если преобразование не удастся, будет возвращено значение null.

### Заголовки

Ktor также позволяет выполнять маршрутизацию на основе значений заголовков HTTP-запроса. Это может быть полезно, например, для определения версии API или аутентификации.

**Пример:**

```kotlin
routing {
    header("X-Custom-Header", "value1") { // Маршрутизация по заголовку "X-Custom-Header" со значением "value1"
        get("/resource") {
            // ...
        }
    }
}
```

В этом примере маршрут `/resource` будет доступен только для запросов, содержащих заголовок `X-Custom-Header` со значением `value1`.

#### Проверка наличия заголовка

Вы можете проверить наличие заголовка, не указывая его значение:

```kotlin
routing {
    header("Authorization") { // Проверка наличия заголовка "Authorization"
        get("/private") {
            // ...
        }
    }
}
```

#### Получение значения заголовка

Для получения значения заголовка используется функция `call.request.header()`:

```kotlin
routing {
    get("/user") {
        val authToken = call.request.header("Authorization") ?: ""
        // ...
    }
}
```

### Регулярные выражения

Для более сложных сценариев маршрутизации можно использовать регулярные выражения.  Это позволяет определять гибкие шаблоны URL-адресов и извлекать информацию из различных частей URL.

**Пример:**

```kotlin
routing {
    get("/products/{productId: \\d+}") { // productId должен быть числом
        val productId = call.parameters["productId"]?.toInt() ?: -1
        // ...
    }
}
```

В этом примере `productId` должен соответствовать регулярному выражению `\d+`, то есть быть непустой последовательностью цифр. 

#### Именованные группы захвата

Регулярные выражения также позволяют использовать именованные группы захвата для извлечения значений из URL:

```kotlin
routing {
    get("/articles/(?<year>\\d{4})/(?<month>\\d{2})/(?<day>\\d{2})/(?<slug>[a-z-]+)") {
        val year = call.parameters["year"]
        val month = call.parameters["month"]
        val day = call.parameters["day"]
        val slug = call.parameters["slug"]
        // ...
    }
}
```

В этом примере регулярное выражение определяет шаблон URL для статьи, где `year`, `month`, `day` и `slug` – это именованные группы захвата. Ktor автоматически извлекает значения этих групп и передает их в обработчик через `call.parameters`.

### Заключение

В этой статье мы рассмотрели расширенные методы маршрутизации в Ktor, которые позволяют более точно определять обработчики для HTTP-запросов. Использование параметров пути, заголовков и регулярных выражений делает вашу маршрутизацию более гибкой и мощной, позволяя обрабатывать широкий спектр сценариев. 
