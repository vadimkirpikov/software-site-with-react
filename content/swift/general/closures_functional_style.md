## Замыкания в функциональном стиле

Замыкания в Swift — это мощный инструмент, позволяющий писать гибкий и выразительный код. В этом разделе мы рассмотрим, как использовать замыкания в функциональном стиле программирования, делая ваш код более декларативным и читаемым.

### Высшие функции

Прежде чем углубляться в функциональные замыкания, важно понять концепцию **высших функций**. В Swift функции являются объектами первого класса, что означает:

- Функции могут присваиваться переменным и константам.
- Функции могут передаваться в качестве аргументов другим функциям.
- Функции могут возвращаться из других функций.

Функции, которые принимают другие функции в качестве аргументов или возвращают функции, называются **высшими функциями**. 

**Пример:**

```swift
func greet(name: String, using greetingFunction: (String) -> String) -> String {
    let greeting = greetingFunction(name)
    return "\(greeting), \(name)!"
}

func sayHello(to name: String) -> String {
    return "Привет"
}

let greeting = greet(name: "Анна", using: sayHello)
print(greeting) // Вывод: Привет, Анна!
```

В этом примере функция `greet` принимает два аргумента: имя `name` и другую функцию `greetingFunction`. Функция `sayHello` принимает имя и возвращает приветствие. При вызове `greet` мы передаем `sayHello` в качестве `greetingFunction`, что позволяет динамически изменять способ формирования приветствия.

### Функции `map`, `filter`, `reduce`

Swift предоставляет ряд встроенных высших функций, которые широко используются в функциональном программировании:

- **`map`**: преобразует каждый элемент коллекции, возвращая новую коллекцию с преобразованными значениями.
- **`filter`**: создает новую коллекцию, содержащую только те элементы исходной коллекции, которые удовлетворяют заданному условию.
- **`reduce`**: объединяет все элементы коллекции в одно значение, применяя функцию-аккумулятор.

**Примеры:**

**`map`**:

```swift
let numbers = [1, 2, 3, 4, 5]
let squares = numbers.map { $0 * $0 }
print(squares) // Вывод: [1, 4, 9, 16, 25]
```

Здесь `map` применяет замыкание `$0 * $0` к каждому элементу массива `numbers`, создавая новый массив `squares` с квадратами чисел.

**`filter`**:

```swift
let evenNumbers = numbers.filter { $0 % 2 == 0 }
print(evenNumbers) // Вывод: [2, 4]
```

`filter` использует замыкание `$0 % 2 == 0` для выбора четных чисел из массива `numbers`.

**`reduce`**:

```swift
let sum = numbers.reduce(0) { $0 + $1 }
print(sum) // Вывод: 15
```

`reduce` начинает с начального значения `0` и применяет замыкание `$0 + $1` к каждому элементу массива `numbers`, накапливая сумму в переменной `$0`.

### Сокращенная запись замыканий

Swift предлагает несколько способов сократить запись замыканий, делая код более лаконичным:

- **Неявное возвращаемое значение:** Если тело замыкания состоит из одного выражения, Swift может автоматически вывести возвращаемое значение.
- **Сокращенные имена аргументов:** Внутри замыканий можно использовать сокращенные имена аргументов, такие как `$0`, `$1` и т.д.
- **Замыкание в качестве последнего аргумента:** Если замыкание является последним аргументом функции, его можно вынести за круглые скобки.

**Пример:**

```swift
let sortedNumbers = numbers.sorted { $0 < $1 }
print(sortedNumbers) // Вывод: [1, 2, 3, 4, 5]
```

В этом примере мы используем сокращенное имя аргумента `$0` и `$1` и выносим замыкание за круглые скобки функции `sorted`.

### Захватывающие списки

Замыкания могут **захватывать** значения из окружающего контекста, в котором они определены.  **Захватывающий список** позволяет управлять тем, как замыкание захватывает значения: по ссылке или по значению.

**Пример:**

```swift
func makeCounter() -> () -> Int {
    var count = 0
    return { 
        count += 1 
        return count 
    }
}

let counter1 = makeCounter()
let counter2 = makeCounter()

print(counter1()) // Вывод: 1
print(counter1()) // Вывод: 2
print(counter2()) // Вывод: 1
```

В этом примере функция `makeCounter` возвращает замыкание, которое увеличивает и возвращает значение переменной `count`. Каждый вызов `makeCounter` создает новое замыкание с собственной копией `count`, что обеспечивает независимую работу счетчиков.

### Практическое применение

Использование замыканий в функциональном стиле может значительно улучшить ваш код, делая его более выразительным, читаемым и тестируемым. Вот несколько примеров:

- **Обработка событий:** Замыкания идеально подходят для обработки событий, таких как нажатия кнопок, сетевые запросы и завершение анимаций.
- **Работа с асинхронным кодом:** Замыкания  упрощают обработку асинхронных операций, таких как сетевые запросы и работа с файлами.
- **Создание собственных функций высшего порядка:** Вы можете создавать собственные функции, принимающие замыкания, для создания абстракций и повторного использования кода.


В этой части мы рассмотрели основы использования замыканий в функциональном стиле. Понимание этих концепций поможет вам писать более чистый, выразительный и поддерживаемый код на Swift.
