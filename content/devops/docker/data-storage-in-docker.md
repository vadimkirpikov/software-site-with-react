## Хранение данных в Docker

Одной из ключевых особенностей Docker является изоляция контейнеров. Это означает, что по умолчанию все данные, созданные внутри контейнера, хранятся в его файловой системе и удаляются при удалении контейнера. Такое поведение может быть неудобным, если требуется сохранить данные приложения после перезапуска или обновить приложение без потери данных. Docker предлагает несколько механизмов для управления хранилищем данных: **volumes** и **bind mounts**.

### Volumes

Volumes - предпочтительный способ хранения данных в Docker. Они управляются Docker Engine, хранятся вне файловой системы контейнера и предлагают ряд преимуществ:

* **Сохранение данных:** Данные в volumes сохраняются даже после удаления контейнера.
* **Переносимость:** Volumes легко перемещать и использовать с разными контейнерами.
* **Управление Docker CLI/API:** Volumes можно создавать, удалять и управлять ими с помощью команд Docker CLI или Docker API.
* **Производительность:** Volumes обычно обеспечивают лучшую производительность по сравнению с bind mounts, особенно в Windows и macOS.

#### Создание и использование volumes

Создать volume можно с помощью команды `docker volume create`:

```
docker volume create my-volume
```

Чтобы использовать volume с контейнером, укажите флаг `-v` или `--volume` при запуске контейнера:

```
docker run -d \
  -v my-volume:/app/data \
  --name my-app \
  my-image
```

В данном примере volume `my-volume` монтируется в директорию `/app/data` внутри контейнера `my-app`.

#### Типы volumes

Docker поддерживает два типа volumes:

* **Локальные volumes:** Хранятся на хост-машине в директории `/var/lib/docker/volumes/`.
* **Внешние volumes:** Управляются сторонними плагинами и могут храниться на сетевых устройствах или в облачных сервисах.

### Bind mounts

Bind mounts позволяют монтировать любую директорию с хост-машины в контейнер. Это может быть полезно для разработки, когда нужно монтировать исходный код приложения в контейнер.

#### Использование bind mounts

Чтобы использовать bind mount, укажите путь к директории на хосте и путь монтирования внутри контейнера через двоеточие (`:`) при запуске контейнера:

```
docker run -d \
  -v /home/user/app-data:/app/data \
  --name my-app \
  my-image
```

В данном примере директория `/home/user/app-data` на хост-машине монтируется в директорию `/app/data` внутри контейнера `my-app`.

#### Ограничения bind mounts

У bind mounts есть несколько ограничений:

* **Переносимость:** Bind mounts привязаны к файловой системе хост-машины, что затрудняет перенос контейнеров на другие машины.
* **Безопасность:** Bind mounts могут предоставить контейнеру доступ к важным файлам и директориям на хосте.
* **Управление:** Bind mounts не управляются Docker Engine и их нужно создавать и удалять вручную.

### Выбор между volumes и bind mounts

В большинстве случаев рекомендуется использовать **volumes** для хранения данных в Docker. Они обеспечивают лучшую переносимость, безопасность и удобство управления. 

Используйте **bind mounts** только в случаях, когда это действительно необходимо, например, для разработки или отладки.

### Пример использования volumes

Рассмотрим пример использования volumes для хранения данных базы данных PostgreSQL.

1. **Создайте volume:**

```
docker volume create postgres-data
```

2. **Запустите контейнер PostgreSQL с использованием volume:**

```
docker run -d \
  -p 5432:5432 \
  -v postgres-data:/var/lib/postgresql/data \
  --name postgres \
  postgres:latest
```

В данном примере volume `postgres-data` монтируется в директорию `/var/lib/postgresql/data` внутри контейнера `postgres`, где PostgreSQL хранит свои данные.

3. **Проверьте, что данные сохраняются после перезапуска контейнера:**

```
# Подключитесь к контейнеру
docker exec -it postgres psql -U postgres

# Создайте таблицу
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

# Выйдите из psql
\q

# Остановите контейнер
docker stop postgres

# Запустите контейнер
docker start postgres

# Подключитесь к контейнеру
docker exec -it postgres psql -U postgres

# Проверьте, что таблица существует
\dt

# Выйдите из psql
\q
```

Данный пример демонстрирует, как volumes позволяют сохранять данные базы данных PostgreSQL даже после перезапуска контейнера. 
