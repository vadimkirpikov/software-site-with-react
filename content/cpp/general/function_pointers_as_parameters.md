## Указатели на функции как параметры

В C++ функции — это объекты первого класса, что означает возможность работы с ними как с любыми другими данными. Мы можем сохранять их в переменных, передавать в качестве аргументов другим функциям и даже возвращать из функций. 

В этом разделе мы сфокусируемся на передаче указателей на функции в качестве параметров. Это мощный инструмент, который позволяет создавать гибкий и многоразовый код.

### Объявление указателей на функции

Для начала разберёмся, как объявлять указатели на функции. Синтаксис может показаться немного запутанным, поэтому разделим его на части:

```c++
return_type (*pointer_name)(parameter_list);
```

* `return_type`: Тип данных, возвращаемый функцией, на которую указывает указатель.
* `(*pointer_name)`: Имя указателя, заключённое в скобки. Скобки необходимы, чтобы компилятор интерпретировал конструкцию как указатель на функцию, а не как функцию, возвращающую указатель.
* `parameter_list`: Список типов параметров функции, на которую указывает указатель.

Рассмотрим пример:

```c++
int (*operation)(int, int);
```

В данном случае `operation` — это указатель на функцию, которая принимает два целочисленных аргумента и возвращает целочисленное значение.

### Присваивание указателям функций

Чтобы использовать указатель на функцию, необходимо связать его с конкретной функцией. Делается это с помощью оператора присваивания (`=`). Важно, чтобы сигнатура функции (тип возвращаемого значения и типы параметров) совпадала с сигнатурой указателя:

```c++
int add(int a, int b) {
  return a + b;
}

int multiply(int a, int b) {
  return a * b;
}

int main() {
  int (*operation)(int, int);

  operation = add; // Присваиваем указателю адрес функции add
  int result1 = operation(5, 3); // Вызываем функцию add через указатель

  operation = multiply; // Теперь operation указывает на функцию multiply
  int result2 = operation(5, 3); // Вызываем функцию multiply через указатель
}
```

### Передача указателей на функции в качестве параметров

Теперь, когда мы умеем объявлять и использовать указатели на функции, можно переходить к их передаче в другие функции. Это открывает широкие возможности для создания гибкого и модульного кода.

Рассмотрим пример функции, которая принимает два числа и указатель на функцию, выполняющую операцию над ними:

```c++
int calculate(int a, int b, int (*operation)(int, int)) {
  return operation(a, b);
}
```

Функция `calculate` принимает три аргумента: два целых числа и указатель на функцию, которая также принимает два целых числа и возвращает целое число. Внутри функции `calculate` происходит вызов функции, на которую указывает `operation`, с аргументами `a` и `b`. 

Теперь мы можем использовать эту функцию с различными операциями:

```c++
int main() {
  int sum = calculate(5, 3, add); // Передаем указатель на функцию add
  int product = calculate(5, 3, multiply); // Передаем указатель на функцию multiply
}
```

### Пример использования: сортировка массива

Представим, что нам нужно написать функцию сортировки массива, которая может работать с различными критериями сортировки. В этом случае мы можем передавать функцию сравнения в качестве параметра:

```c++
#include <iostream>

bool ascending(int a, int b) {
  return a < b;
}

bool descending(int a, int b) {
  return a > b;
}

void bubble_sort(int arr[], int size, bool (*compare)(int, int)) {
  for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
      if (compare(arr[j + 1], arr[j])) {
        // Меняем элементы местами
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}

int main() {
  int numbers[] = {5, 2, 8, 1, 9};
  int size = sizeof(numbers) / sizeof(numbers[0]);

  bubble_sort(numbers, size, ascending); // Сортировка по возрастанию
  for (int i = 0; i < size; i++) {
    std::cout << numbers[i] << " ";
  }
  std::cout << std::endl;

  bubble_sort(numbers, size, descending); // Сортировка по убыванию
  for (int i = 0; i < size; i++) {
    std::cout << numbers[i] << " ";
  }
  std::cout << std::endl;
}
```

В данном примере функция `bubble_sort` принимает массив целых чисел, его размер и указатель на функцию сравнения. Функция сравнения принимает два целых числа и возвращает `true`, если первый элемент должен стоять перед вторым, и `false` в противном случае.

Мы определили две функции сравнения: `ascending` (для сортировки по возрастанию) и `descending` (для сортировки по убыванию). В зависимости от переданной функции сравнения, `bubble_sort` будет сортировать массив по-разному.

### Заключение

Передача указателей на функции в качестве параметров — это мощный инструмент, который делает код более гибким, модульным и лаконичным. Он позволяет абстрагироваться от конкретной реализации функций и использовать различные алгоритмы и стратегии без дублирования кода.