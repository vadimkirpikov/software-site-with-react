## Очередь в C++: std::queue

В программировании часто возникает необходимость работы с данными по принципу "первым пришёл - первым вышел" (FIFO - First In, First Out). Для этого в стандартной библиотеке шаблонов (STL) C++ предусмотрен контейнер `std::queue`. 

`std::queue` - это шаблон класса, представляющий собой очередь. Он предоставляет ограниченный набор методов, необходимых для работы с очередью, скрывая при этом детали реализации. 

### Создание очереди

Для создания объекта очереди используется следующий синтаксис:

```c++
#include <queue>

std::queue<тип_элементов> имя_очереди;
```

Где:

* `тип_элементов` - тип данных, которые будет хранить очередь. Это может быть любой встроенный тип данных (int, double, char и т.д.) или пользовательский тип данных.
* `имя_очереди` - имя создаваемого объекта очереди.

**Пример:**

```c++
#include <queue>
#include <string>

int main() {
  // Очередь целых чисел
  std::queue<int> очередь_чисел;

  // Очередь строк
  std::queue<std::string> очередь_строк;

  return 0;
}
```

### Основные операции с очередью

`std::queue` предоставляет следующие основные операции:

| Метод        | Описание                                        |
|--------------|-------------------------------------------------|
| `push(val)` | Добавляет элемент `val` в конец очереди     |
| `pop()`      | Удаляет первый элемент из очереди               |
| `front()`    | Возвращает ссылку на первый элемент очереди      |
| `back()`     | Возвращает ссылку на последний элемент очереди |
| `empty()`    | Проверяет, пуста ли очередь                    |
| `size()`     | Возвращает количество элементов в очереди      |

**Пример использования:**

```c++
#include <iostream>
#include <queue>

int main() {
  std::queue<int> очередь;

  // Добавление элементов в очередь
  очередь.push(10);
  очередь.push(20);
  очередь.push(30);

  // Вывод размера очереди
  std::cout << "Размер очереди: " << очередь.size() << std::endl; // Вывод: 3

  // Вывод элементов очереди
  while (!очередь.empty()) {
    std::cout << очередь.front() << " "; // Вывод: 10 20 30
    очередь.pop();
  }
  std::cout << std::endl;

  return 0;
}
```

### Пример практического применения

Рассмотрим пример использования `std::queue` для моделирования работы принтера.

```c++
#include <iostream>
#include <queue>
#include <string>

// Структура для хранения информации о задании на печать
struct PrintJob {
  std::string documentName;
  int pages;
};

int main() {
  // Создаем очередь заданий на печать
  std::queue<PrintJob> printQueue;

  // Добавляем задания в очередь
  printQueue.push({"Документ 1", 10});
  printQueue.push({"Документ 2", 5});
  printQueue.push({"Документ 3", 2});

  // Обрабатываем очередь заданий
  while (!printQueue.empty()) {
    // Получаем первое задание из очереди
    PrintJob currentJob = printQueue.front();

    // "Печатаем" документ
    std::cout << "Печать документа: " << currentJob.documentName << std::endl;
    std::cout << "Количество страниц: " << currentJob.pages << std::endl;

    // Удаляем задание из очереди
    printQueue.pop();
  }

  return 0;
}
```

В этом примере мы создали очередь `printQueue`, которая хранит задания на печать типа `PrintJob`. Каждое задание содержит имя документа и количество страниц. 

Затем мы добавляем три задания в очередь и обрабатываем их в порядке поступления. Для каждого задания выводим информацию о документе и "печатаем" его. После этого удаляем задание из очереди.

### Заключение

`std::queue` - это удобный инструмент для работы с данными по принципу FIFO. Он прост в использовании и позволяет эффективно организовать обработку данных в порядке их поступления.
