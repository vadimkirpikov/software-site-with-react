## unique_ptr<T>: интеллектуальный указатель для единоличного владения

В C++, наряду с ручным управлением памятью, важную роль играют умные указатели, упрощающие этот процесс и делающие код безопаснее.  `unique_ptr<T>` - один из таких умных указателей, предоставляемый стандартной библиотекой C++.  Он представляет собой объект,  который владеет другим объектом, выделяя и освобождая память автоматически.

### Особенности unique_ptr<T>

* **Единоличное владение:**  `unique_ptr` гарантирует, что только один  `unique_ptr`  может указывать на один и тот же объект в памяти. Это исключает проблемы, связанные с множественным освобождением памяти. 
* **Автоматическое управление памятью:**  При выходе `unique_ptr` из области видимости, деструктор  `unique_ptr` автоматически удаляет управляемый объект, предотвращая утечки памяти.
* **Неявное преобразование в bool:**  `unique_ptr` может быть использован в условных выражениях и циклах. Пустой `unique_ptr` (не указывающий ни на один объект)  эквивалентен `false`, а непустой - `true`.

### Объявление и инициализация

Объявление `unique_ptr` осуществляется с указанием типа данных объекта, которым он будет владеть:

```c++
std::unique_ptr<int> ptr1;      // Создает пустой unique_ptr для хранения int
std::unique_ptr<double> ptr2; // Создает пустой unique_ptr для хранения double
```

Инициализировать `unique_ptr` можно несколькими способами:

* **`std::make_unique` (рекомендуется):**

```c++
std::unique_ptr<int> ptr3 = std::make_unique<int>(10); // Создает unique_ptr, владеющий int со значением 10
```

* **`new`:**

```c++
std::unique_ptr<int> ptr4(new int(20)); // Создает unique_ptr, владеющий int со значением 20
```

* **`nullptr`:**

```c++
std::unique_ptr<int> ptr5(nullptr);  // Создает пустой unique_ptr
```

### Доступ к управляемому объекту

Для доступа к объекту, которым владеет `unique_ptr`, используются операторы разыменования (`*`) и доступа к члену (`->`):

```c++
std::unique_ptr<int> ptr = std::make_unique<int>(42);

*ptr = 55; // Изменение значения управляемого объекта
int value = *ptr; // Чтение значения управляемого объекта

std::unique_ptr<std::string> strPtr = std::make_unique<std::string>("Hello");

std::cout << strPtr->length() << std::endl; // Вывод длины строки
```

### Передача владения

`unique_ptr` не может быть скопирован, но можно передать владение объектом другому `unique_ptr`:

* **`std::move`:**

```c++
std::unique_ptr<int> ptr1 = std::make_unique<int>(30);
std::unique_ptr<int> ptr2 = std::move(ptr1); // ptr2 теперь владеет объектом, ptr1 становится пустым
```

* **Возврат из функции:**

```c++
std::unique_ptr<int> createUniquePtr() {
  return std::make_unique<int>(100);
}

std::unique_ptr<int> ptr = createUniquePtr(); // ptr получает владение объектом, созданным в функции
```

### Примеры использования

Рассмотрим пример использования `unique_ptr` для управления ресурсами:

```c++
#include <iostream>
#include <memory>

class Resource {
public:
  Resource() { 
    std::cout << "Ресурс создан" << std::endl; 
  }
  ~Resource() { 
    std::cout << "Ресурс удален" << std::endl; 
  }
  void doSomething() { 
    std::cout << "Ресурс выполняет действие" << std::endl; 
  }
};

void useResource(std::unique_ptr<Resource> res) {
  res->doSomething();
}

int main() {
  {
    std::unique_ptr<Resource> resPtr = std::make_unique<Resource>();
    useResource(std::move(resPtr)); // Передача владения в функцию
  } // resPtr выходит из области видимости, ресурс автоматически удаляется
  std::cout << "Конец программы" << std::endl;
  return 0;
}
```

Вывод программы:

```
Ресурс создан
Ресурс выполняет действие
Ресурс удален
Конец программы
```

### Заключение

`unique_ptr` - мощный инструмент для управления ресурсами в C++. Он обеспечивает безопасное и эффективное владение объектами, предотвращая утечки памяти и упрощая код.  Использование `unique_ptr`  рекомендовано везде, где требуется единоличное владение ресурсами.
