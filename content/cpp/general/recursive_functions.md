## Рекурсивные функции

Рекурсивная функция – это функция, которая вызывает сама себя в процессе выполнения. Этот приём может быть очень мощным инструментом для решения задач, которые можно разбить на более мелкие, однотипные подзадачи.

### Принцип работы рекурсии

Работа рекурсивной функции основана на двух основных принципах:

1. **Базовый случай (условие выхода):** каждая рекурсивная функция должна иметь условие, при котором рекурсия прекращается. Без этого условия функция будет вызывать сама себя бесконечно, что приведёт к переполнению стека.
2. **Рекурсивный шаг:** на этом этапе функция выполняет часть работы и вызывает сама себя для решения подзадачи, приближая решение к базовому случаю.

Рассмотрим пример рекурсивной функции для вычисления факториала числа:

```c++
int factorial(int n) {
  // Базовый случай: факториал 0 равен 1
  if (n == 0) {
    return 1;
  } else {
    // Рекурсивный шаг: n! = n * (n-1)!
    return n * factorial(n - 1); 
  }
}
```

В этой функции:

* Базовый случай: `n == 0`, при котором функция возвращает `1`.
* Рекурсивный шаг:  функция возвращает результат умножения `n` на факториал `n-1`, вычисленный рекурсивно.

### Преимущества и недостатки рекурсии

#### Преимущества:

* **Элегантность и читаемость:** для некоторых задач рекурсивное решение выглядит более естественно и лаконично, чем итеративное.
* **Решение задач "разделяй и властвуй":** рекурсия идеально подходит для задач, которые можно разбить на более мелкие, однотипные подзадачи, например, обход деревьев, работа с фракталами, алгоритмы сортировки (быстрая сортировка, сортировка слиянием).

#### Недостатки:

* **Переполнение стека:** рекурсия может привести к переполнению стека вызовов, если глубина рекурсии слишком велика.
* **Производительность:** рекурсивные функции могут работать медленнее итеративных аналогов, так как каждый вызов функции требует выделения памяти под новый фрейм стека.

### Хвостовая рекурсия

Хвостовая рекурсия – это частный случай рекурсии, при котором рекурсивный вызов функции является последней выполняемой операцией.  Компиляторы могут оптимизировать хвостовую рекурсию, заменяя её на итерацию, что позволяет избежать переполнения стека и повысить производительность.

Пример функции с хвостовой рекурсией для вычисления факториала:

```c++
int factorialTailRec(int n, int acc = 1) {
  // Базовый случай
  if (n == 0) {
    return acc;
  } else {
    // Хвостовой рекурсивный вызов: результат вычислений передается в аргументе acc
    return factorialTailRec(n - 1, acc * n); 
  }
}
```

### Примеры использования рекурсивных функций

**1. Вычисление чисел Фибоначчи:**

```c++
int fibonacci(int n) {
  // Базовые случаи
  if (n == 0) return 0;
  if (n == 1) return 1;

  // Рекурсивный шаг
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**2. Вычисление суммы элементов массива:**

```c++
int sumArray(int arr[], int size) {
  // Базовый случай
  if (size == 0) {
    return 0;
  } else {
    // Рекурсивный шаг
    return arr[size - 1] + sumArray(arr, size - 1);
  }
}
```

**3. Определение, является ли строка палиндромом:**

```c++
bool isPalindrome(const std::string& str, int left, int right) {
  // Базовый случай: пустая строка или строка из одного символа
  if (left >= right) { 
    return true; 
  } 
  // Рекурсивный шаг
  if (str[left] == str[right]) {
    return isPalindrome(str, left + 1, right - 1);
  } else {
    return false;
  }
}
```

### Заключение

Рекурсия – это мощный инструмент, который может быть очень полезен при решении определённого типа задач.  Важно понимать принципы работы рекурсии, её преимущества и недостатки, чтобы применять её эффективно и безопасно.
