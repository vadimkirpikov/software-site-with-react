## Двусторонняя очередь: std::deque<>

В C++ `std::deque` (сокращение от "double-ended queue") представляет собой динамический массив, который позволяет эффективно добавлять и удалять элементы как в начале, так и в конце. В отличие от `std::vector`, `std::deque` не гарантирует хранения элементов в непрерывном блоке памяти.

### Особенности std::deque

* **Двусторонняя вставка и удаление:** Элементы можно эффективно добавлять и удалять как в начале, так и в конце очереди. 
* **Динамический размер:** Размер `std::deque` автоматически увеличивается при необходимости.
* **Отсутствие гарантии на непрерывность памяти:**  В отличие от `std::vector`, элементы `std::deque` могут храниться в несмежных блоках памяти.
* **Произвольный доступ:**  `std::deque` предоставляет доступ к элементам по индексу с помощью оператора `[]` и метода `at()`, как и `std::vector`.

### Создание deque

Для использования `std::deque` необходимо подключить заголовочный файл `<deque>`:

```cpp
#include <deque>
```

**Создание пустого deque:**

```cpp
std::deque<int> deque1; // Пустой deque целых чисел
```

**Создание deque с заданным размером:**

```cpp
std::deque<double> deque2(5); // deque из 5 элементов типа double, инициализированных значением 0.0
```

**Создание deque с заданным размером и значением:**

```cpp
std::deque<char> deque3(3, 'A'); // deque из 3 элементов типа char, инициализированных значением 'A' 
```

**Создание deque из другого deque:**

```cpp
std::deque<int> deque4(deque1); // deque4 будет копией deque1
```

**Создание deque из диапазона:**

```cpp
int arr[] = {1, 2, 3, 4, 5};
std::deque<int> deque5(arr, arr + 5); // deque5 будет содержать элементы массива arr
```

### Основные операции

**Добавление элементов:**

* `push_back(value)`: Добавляет элемент `value` в конец deque.
* `push_front(value)`: Добавляет элемент `value` в начало deque.

```cpp
std::deque<int> numbers;
numbers.push_back(10); // Добавляем 10 в конец
numbers.push_front(5); // Добавляем 5 в начало
// deque: {5, 10}
```

**Удаление элементов:**

* `pop_back()`: Удаляет последний элемент deque.
* `pop_front()`: Удаляет первый элемент deque.

```cpp
numbers.pop_front(); // Удаляем 5
// deque: {10}
```

**Доступ к элементам:**

* `front()`: Возвращает ссылку на первый элемент deque.
* `back()`: Возвращает ссылку на последний элемент deque.
* `operator[] (index)`: Возвращает ссылку на элемент по индексу `index`.
* `at(index)`: Возвращает ссылку на элемент по индексу `index` с проверкой выхода за пределы.

```cpp
int first = numbers.front(); // first = 10
int last = numbers.back(); // last = 10
int third = numbers[2]; // third = 15 (предполагая, что в deque есть 3 элемента)
```

**Другие полезные методы:**

* `empty()`: Проверяет, пуст ли deque.
* `size()`: Возвращает количество элементов в deque.
* `clear()`: Удаляет все элементы из deque.
* `resize(new_size)`: Изменяет размер deque до `new_size`.
* `insert(iterator, value)`: Вставляет элемент `value` перед элементом, на который указывает итератор `iterator`.

```cpp
if (numbers.empty()) {
  // deque пуст
} else {
  // deque не пуст
}

int size = numbers.size(); // size = 1

numbers.clear(); // Очищаем deque
```

### Итераторы

`std::deque` предоставляет итераторы для обхода своих элементов. Итераторы можно получить с помощью следующих методов:

* `begin()`: Возвращает итератор, указывающий на первый элемент deque.
* `end()`: Возвращает итератор, указывающий на позицию после последнего элемента deque.
* `rbegin()`: Возвращает обратный итератор, указывающий на последний элемент deque.
* `rend()`: Возвращает обратный итератор, указывающий на позицию перед первым элементом deque.

```cpp
// Использование итератора для обхода deque
for (std::deque<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
  std::cout << *it << " ";
}

// Использование обратного итератора для обхода deque в обратном порядке
for (std::deque<int>::reverse_iterator it = numbers.rbegin(); it != numbers.rend(); ++it) {
  std::cout << *it << " ";
}
```

### Пример использования std::deque

```cpp
#include <iostream>
#include <deque>

int main() {
  // Создаем deque для хранения имен
  std::deque<std::string> names;

  // Добавляем имена в конец deque
  names.push_back("Alice");
  names.push_back("Bob");
  names.push_back("Charlie");

  // Выводим размер deque
  std::cout << "Размер deque: " << names.size() << std::endl;

  // Выводим все имена в deque
  std::cout << "Имена в deque: ";
  for (const auto& name : names) {
    std::cout << name << " ";
  }
  std::cout << std::endl;

  // Добавляем имя в начало deque
  names.push_front("David");

  // Удаляем имя с конца deque
  names.pop_back();

  // Выводим обновленный список имен
  std::cout << "Обновленные имена в deque: ";
  for (const auto& name : names) {
    std::cout << name << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

Вывод программы:

```
Размер deque: 3
Имена в deque: Alice Bob Charlie 
Обновленные имена в deque: David Alice Bob 
```

### Выбор между std::deque и std::vector

В большинстве случаев `std::vector` является предпочтительным выбором для хранения последовательностей элементов. Однако `std::deque` может быть более эффективным в следующих случаях:

* **Частые вставки и удаления элементов в начале:**  Вставка и удаление элементов в начале `std::vector` требует сдвига всех последующих элементов, что может быть неэффективно для больших векторов. `std::deque` выполняет эти операции за константное время.
* **Неизвестен размер данных:** `std::deque` автоматически выделяет больше памяти при необходимости, что делает его хорошим выбором, когда размер данных неизвестен заранее.

В остальных случаях, `std::vector` обычно обеспечивает лучшую производительность, поскольку его элементы хранятся в непрерывном блоке памяти, что обеспечивает более быстрый доступ к элементам и лучшую локальность данных.

### Заключение

`std::deque` - это мощный инструмент для работы с динамическими последовательностями данных, который предлагает гибкость и эффективность в различных сценариях. Понимание особенностей `std::deque` поможет вам выбрать наиболее подходящую структуру данных для вашей задачи.
