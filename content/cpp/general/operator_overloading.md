## Перегрузка операторов

Перегрузка операторов — мощный инструмент C++, позволяющий определить поведение операторов (например, +, -, *, /) для пользовательских типов данных. Это делает код более интуитивным, читаемым и похожим на работу с встроенными типами.

### Базовый синтаксис

Объявление перегруженного оператора напоминает объявление функции, за исключением того, что имя функции заменяется ключевым словом `operator`, за которым следует символ оператора:

```cpp
class Vector2D {
public:
  double x, y;

  // Перегрузка оператора + для сложения векторов
  Vector2D operator+(const Vector2D& other) const {
    return Vector2D{x + other.x, y + other.y};
  }
};
```

В данном примере мы перегружаем оператор `+` для класса `Vector2D`. Теперь можно складывать экземпляры этого класса, как если бы это были встроенные типы:

```cpp
Vector2D v1{1.0, 2.0};
Vector2D v2{3.0, 4.0};
Vector2D v3 = v1 + v2; // v3 = {4.0, 6.0}
```

### Типы перегружаемых операторов

В C++ можно перегрузить большинство операторов, включая:

* Арифметические операторы: `+`, `-`, `*`, `/`, `%`, `++`, `--`
* Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`
* Логические операторы: `!`, `&&`, `||`
* Операторы присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`
* Операторы доступа к членам класса: `[]`, `->`, `*`
* Другие операторы: `<<`, `>>`, `&`, `|`, `^`, `~`, `new`, `delete`, `,`

### Способы перегрузки операторов

Перегрузить оператор можно двумя способами:

1. **Функцией-членом класса**: В этом случае оператор определяется как метод класса. Первый операнд неявно передается через указатель `this`. Этот способ подходит, когда оператор модифицирует объект или требует доступа к его закрытым членам.

   ```cpp
   class Complex {
   public:
     double real, imag;

     // Перегрузка оператора * как функции-члена
     Complex operator*(const Complex& other) const {
       return Complex{real * other.real - imag * other.imag, 
                      real * other.imag + imag * other.real};
     }
   };
   ```

2. **Функцией-не членом класса**: В этом случае оператор определяется вне класса как обычная функция, принимающая операнды в качестве аргументов. Этот способ подходит, когда оператор не модифицирует объект и не нуждается в доступе к его закрытым членам.

   ```cpp
   // Перегрузка оператора << как функции-не члена
   std::ostream& operator<<(std::ostream& os, const Complex& c) {
     os << c.real << " + " << c.imag << "i";
     return os;
   }
   ```

### Некоторые особенности и ограничения

* Не все операторы можно перегружать (например, `::`, `.`, `sizeof`).
* Нельзя изменять приоритет операторов, их ассоциативность и количество операндов.
* Хотя и можно создавать новые операторы, рекомендуется перегружать только существующие, чтобы код оставался понятным.

### Примеры использования

**1. Перегрузка оператора индексации `[]` для собственного класса массива:**

```cpp
template <typename T>
class MyArray {
private:
  T* data;
  size_t size;

public:
  MyArray(size_t s) : data(new T[s]), size(s) {}
  ~MyArray() { delete[] data; }

  // Перегрузка оператора [] для доступа к элементам массива
  T& operator[](size_t index) {
    if (index >= size) {
      throw std::out_of_range("Индекс вне границ");
    }
    return data[index];
  }
};
```

**2. Перегрузка оператора вывода `<<` для вывода объекта в поток:**

```cpp
class Point {
public:
  int x, y;

  friend std::ostream& operator<<(std::ostream& os, const Point& p);
};

std::ostream& operator<<(std::ostream& os, const Point& p) {
  os << "(" << p.x << ", " << p.y << ")";
  return os;
}
```

### Заключение

Перегрузка операторов — мощный инструмент, делающий код на C++ более выразительным и удобным в использовании. Применяйте ее с умом, соблюдая семантику операторов и не злоупотребляя сложностью.