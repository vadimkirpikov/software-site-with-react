## Скрытие функционала базового класса

В объектно-ориентированном программировании наследование позволяет создавать новые классы на основе существующих, наследуя их данные и функционал. Однако бывают ситуации, когда необходимо ограничить доступ к определенным членам базового класса из производного класса или полностью скрыть их. В C++ для этого используются механизмы перегрузки имен и ключевое слово `using`.

### Перегрузка имен

Если в производном классе объявить функцию с тем же именем и сигнатурой (типы параметров и возвращаемое значение), что и функция в базовом классе, то функция базового класса будет скрыта. Это называется **перегрузкой имен**. 

**Пример:**

```c++
#include <iostream>

class Base {
public:
    void print(int value) {
        std::cout << "Base: " << value << std::endl;
    }
};

class Derived : public Base {
public:
    void print(double value) { // Скрывает Base::print(int)
        std::cout << "Derived: " << value << std::endl;
    }
};

int main() {
    Derived d;
    d.print(10);    // Вызов Derived::print(double)
    // d.print(10.5); // Ошибка компиляции - Base::print(int) скрыт
    return 0;
}
```

В данном примере `Derived::print(double)` скрывает `Base::print(int)`, даже несмотря на различие в типе параметра.  Попытка вызвать `d.print(10.5)` приведет к ошибке компиляции, так как компилятор не найдет подходящей функции в классе `Derived`.

### Ключевое слово using

Для восстановления доступа к скрытым членам базового класса используется ключевое слово **using**. 

**Пример:**

```c++
#include <iostream>

class Base {
public:
    void print(int value) {
        std::cout << "Base: " << value << std::endl;
    }
};

class Derived : public Base {
public:
    using Base::print; // Восстановление доступа к Base::print(int)
    void print(double value) { 
        std::cout << "Derived: " << value << std::endl;
    }
};

int main() {
    Derived d;
    d.print(10);     // Вызов Base::print(int)
    d.print(10.5);   // Вызов Derived::print(double)
    return 0;
}
```

В этом примере `using Base::print;` восстанавливает доступ к функции `print(int)` из базового класса. Теперь компилятор может разрешить вызов `d.print(10)`, вызывая соответствующую функцию из базового класса.

### Скрытие приватных членов

Важно отметить, что приватные члены базового класса всегда скрыты в производном классе, даже если используется публичное наследование. Это базовый принцип инкапсуляции.

### Зачем скрывать функционал?

Существует несколько причин для скрытия функционала базового класса:

* **Предотвращение использования неподходящих методов:** В некоторых случаях методы базового класса могут быть некорректны или нежелательны для использования в производном классе.
* **Специализация поведения:** Производный класс может переопределить метод базового класса, чтобы обеспечить более специфичное поведение.
* **Улучшение читаемости кода:** Скрытие неиспользуемых методов базового класса делает код производного класса более чистым и понятным.

### Заключение

Скрытие функционала базового класса - важный механизм в C++, позволяющий контролировать доступ к членам базового класса и создавать более специализированные и безопасные классы. Понимание принципов перегрузки имен и использования ключевого слова `using`  - неотъемлемая часть работы с наследованием в C++. 
