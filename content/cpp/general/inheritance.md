## Наследование

Наследование – это один из фундаментальных принципов объектно-ориентированного программирования (ООП). Оно позволяет создавать новые классы (производные классы) на основе существующих (базовые классы), наследуя их свойства (данные-члены) и функции (функции-члены).

**Зачем нужно наследование?**

* **Повторное использование кода:** Наследование позволяет избежать дублирования кода. Вместо того, чтобы писать один и тот же код для разных классов, можно создать базовый класс с общими свойствами и функциями, а затем наследовать от него производные классы, добавляя только специфические для них свойства и функции.
* **Иерархия классов:** Наследование позволяет создавать иерархические структуры классов, где более общие классы располагаются выше в иерархии, а более специализированные – ниже.
* **Полиморфизм:** Наследование играет ключевую роль в реализации полиморфизма, который позволяет обрабатывать объекты разных классов единообразно.

### Базовый и производный класс

Базовый класс – это класс, от которого наследуются другие классы. 
Производный класс – это класс, который наследуется от базового класса. Производный класс наследует все нестатические члены базового класса, за исключением конструкторов, деструктора, оператора присваивания и функции-друга.

### Типы наследования

Существует три типа наследования:

| Тип наследования | Описание |
|---|---|
| **public** | Публичное наследование. Публичные члены базового класса становятся публичными членами производного класса. Защищенные члены базового класса становятся защищенными членами производного класса. |
| **protected** | Защищенное наследование. Публичные и защищенные члены базового класса становятся защищенными членами производного класса. |
| **private** | Приватное наследование. Публичные и защищенные члены базового класса становятся приватными членами производного класса. |

### Синтаксис

```c++
class BaseClass {
 // Члены базового класса
};

class DerivedClass: public BaseClass {
 // Члены производного класса
};
```

В этом примере `DerivedClass` наследуется публично от `BaseClass`.

### Пример

```c++
#include <iostream>
#include <string>

using namespace std;

// Базовый класс "Фигура"
class Shape {
protected:
    string color;

public:
    Shape(const string& c) : color(c) {}

    void setColor(const string& c) {
        color = c;
    }

    string getColor() const {
        return color;
    }

    virtual double getArea() const {
        return 0.0; 
    }
};

// Производный класс "Круг"
class Circle : public Shape {
private:
    double radius;

public:
    Circle(const string& c, double r) : Shape(c), radius(r) {}

    void setRadius(double r) {
        radius = r;
    }

    double getRadius() const {
        return radius;
    }

    // Переопределение функции getArea()
    double getArea() const override {
        return 3.14159 * radius * radius;
    }
};

int main() {
    Circle circle("Красный", 5.0);

    cout << "Цвет круга: " << circle.getColor() << endl;
    cout << "Радиус круга: " << circle.getRadius() << endl;
    cout << "Площадь круга: " << circle.getArea() << endl;

    return 0;
}
```

**Описание кода:**

1. **Базовый класс `Shape`:**
   - Имеет защищенный член `color` (цвет фигуры).
   - Имеет конструктор, принимающий цвет.
   - Имеет функции для установки и получения цвета.
   - Имеет виртуальную функцию `getArea()`, возвращающую площадь фигуры. По умолчанию возвращает 0.0. 

2. **Производный класс `Circle`:**
   - Наследуется публично от `Shape`.
   - Имеет приватный член `radius` (радиус круга).
   - Имеет конструктор, принимающий цвет и радиус, и инициализирующий базовый класс `Shape`.
   - Имеет функции для установки и получения радиуса.
   - Переопределяет функцию `getArea()` для вычисления площади круга.

3. **Функция `main()`:**
   - Создает объект класса `Circle` с заданным цветом и радиусом.
   - Выводит цвет, радиус и площадь круга.

**Вывод:**

```
Цвет круга: Красный
Радиус круга: 5
Площадь круга: 78.5397
```

### Ключевые моменты:

* Ключевое слово `virtual` перед функцией-членом базового класса указывает на то, что эта функция может быть переопределена в производных классах.
* Ключевое слово `override` после сигнатуры функции-члена производного класса указывает на то, что эта функция переопределяет виртуальную функцию базового класса.
* Виртуальные функции и их переопределение – основа полиморфизма, который будет рассмотрен подробнее в следующих разделах. 
