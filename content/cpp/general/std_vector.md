## Динамические массивы: std::vector<>

В процессе разработки программ часто возникает необходимость хранить коллекции данных переменного размера. Стандартная библиотека C++ предоставляет удобный инструмент для работы с такими коллекциями — контейнер `std::vector`. Этот контейнер представляет собой динамический массив, способный автоматически управлять выделением и освобождением памяти по мере необходимости.

### Основы std::vector

Для начала работы с `std::vector` необходимо подключить заголовочный файл `<vector>`:

```cpp
#include <vector>
```

Объявление вектора осуществляется с указанием типа данных, которые он будет хранить:

```cpp
std::vector<int> numbers; // Вектор для хранения целых чисел
std::vector<std::string> names; // Вектор для хранения строк
```

### Инициализация вектора

Существует несколько способов инициализации `std::vector`:

1. **Пустой вектор:**
    ```cpp
    std::vector<double> values; // Создает пустой вектор values
    ```

2. **Вектор заданного размера:**
    ```cpp
    std::vector<int> data(5); // Вектор data из 5 элементов, 
                               // инициализированных значением 0
    ```

3. **Вектор заданного размера и значения:**
    ```cpp
    std::vector<char> letters(3, 'a'); // Вектор letters из 3 элементов, 
                                       // каждый из которых равен 'a'
    ```

4. **Инициализация списком:**
    ```cpp
    std::vector<int> numbers = {1, 2, 3, 4, 5}; // Вектор numbers 
                                                   // с заданными значениями
    ```

5. **Инициализация диапазоном:**
    ```cpp
    int array[] = {10, 20, 30};
    std::vector<int> data(std::begin(array), std::end(array)); // Вектор data, 
                                                                  // скопированный из массива array
    ```

### Доступ к элементам вектора

Доступ к элементам `std::vector` осуществляется с помощью оператора индексирования `[]`, как и в обычном массиве. Индексы начинаются с 0.

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
std::cout << numbers[0]; // Вывод: 1
std::cout << numbers[2]; // Вывод: 3
```

Также можно использовать метод `at()` для доступа к элементам с проверкой выхода за границы:

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};
try {
  std::cout << numbers.at(10); // Попытка доступа к элементу с индексом 10
} catch (const std::out_of_range& e) {
  std::cerr << "Ошибка: выход за границы вектора: " << e.what() << std::endl;
}
```

### Основные операции с вектором

`std::vector` предоставляет множество полезных методов для работы с данными:

* **size():** Возвращает количество элементов в векторе.
* **empty():** Проверяет, пуст ли вектор.
* **push_back():** Добавляет элемент в конец вектора.
* **pop_back():** Удаляет последний элемент вектора.
* **insert():** Вставляет элементы в указанную позицию.
* **erase():** Удаляет элементы из вектора.
* **clear():** Очищает вектор, удаляя все элементы.

**Пример использования методов:**

```cpp
#include <iostream>
#include <vector>

int main() {
  std::vector<int> numbers = {1, 2, 3};

  std::cout << "Размер вектора: " << numbers.size() << std::endl; // Вывод: 3

  numbers.push_back(4); // Добавляем элемент 4 в конец вектора
  std::cout << "Новый размер вектора: " << numbers.size() << std::endl; // Вывод: 4

  numbers.pop_back(); // Удаляем последний элемент (4)

  numbers.insert(numbers.begin() + 1, 5); // Вставляем 5 перед элементом с индексом 1

  for (int number : numbers) {
    std::cout << number << " "; // Вывод: 1 5 2 3
  }
  std::cout << std::endl;

  numbers.clear(); // Очищаем вектор
  std::cout << "Вектор пуст: " << numbers.empty() << std::endl; // Вывод: 1 (true)

  return 0;
}
```

### Итераторы

Итераторы предоставляют способ доступа к элементам вектора независимо от их индексов. 

* **begin():** Возвращает итератор на первый элемент вектора.
* **end():** Возвращает итератор на элемент, следующий за последним элементом вектора.
* **cbegin(), cend():** Возвращают константные итераторы, не позволяющие изменять значения элементов.

**Пример использования итераторов:**

```cpp
#include <iostream>
#include <vector>

int main() {
  std::vector<int> numbers = {1, 2, 3, 4, 5};

  // Использование итератора для вывода элементов
  for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
    std::cout << *it << " "; // Вывод: 1 2 3 4 5
  }
  std::cout << std::endl;

  // Использование константного итератора
  for (std::vector<int>::const_iterator it = numbers.cbegin(); it != numbers.cend(); ++it) {
    // *it = 10; // Ошибка компиляции: нельзя изменять значение через константный итератор
    std::cout << *it << " "; // Вывод: 1 2 3 4 5
  }
  std::cout << std::endl;

  return 0;
}
```

### Дополнительные возможности

`std::vector` предоставляет множество других возможностей, таких как:

* **Сортировка элементов:** `std::sort(vector.begin(), vector.end())`
* **Поиск элементов:** `std::find(vector.begin(), vector.end(), value)`
* **Удаление дубликатов:** `vector.erase(std::unique(vector.begin(), vector.end()), vector.end())`

`std::vector` - это мощный и гибкий инструмент для работы с динамическими массивами в C++. Освоив основы его использования, вы сможете значительно упростить разработку программ, требующих хранения и обработки коллекций данных.
