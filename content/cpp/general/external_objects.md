## Внешние объекты

В языке C++ объекты могут обладать **внешним связыванием**. Это означает, что имя объекта видимо не только в том блоке кода, где оно объявлено, но и в других файлах программы. Внешние объекты играют важную роль в организации кода и создании крупных программных проектов. 

### Объявление и определение

Чтобы использовать внешний объект, необходимо его сначала **объявить**, а затем **определить**. 

**Объявление** сообщает компилятору о существовании объекта, его типе и имени. Объявление не выделяет память под объект. Для объявления внешнего объекта используется ключевое слово `extern`.

```c++
// Объявление внешней переменной
extern int global_counter; 
```

**Определение** выделяет память под объект и может задавать его начальное значение.  Определение внешнего объекта  выглядит как обычное определение переменной.

```c++
// Определение внешней переменной
int global_counter = 0;
```

Важно помнить:

*  **Внешний объект может быть определен только один раз.** Повторное определение приведет к ошибке компиляции. 
* **Внешний объект может быть объявлен множество раз.** Объявления в разных файлах позволяют использовать объект в каждом из них.

### Пример использования

Рассмотрим пример использования внешних объектов в программе, состоящей из двух файлов: `main.cpp` и `counter.cpp`. 

**Файл `counter.cpp`:**

```c++
// counter.cpp
#include <iostream>

// Определение внешней переменной
int global_counter = 0;

void increment_counter() {
  global_counter++;
  std::cout << "Счетчик увеличен: " << global_counter << std::endl;
}
```

**Файл `main.cpp`:**

```c++
// main.cpp
#include <iostream>

// Объявление внешней переменной
extern int global_counter;

// Объявление функции
void increment_counter();

int main() {
  std::cout << "Начальное значение счетчика: " << global_counter << std::endl;
  increment_counter();
  increment_counter();
  std::cout << "Конечное значение счетчика: " << global_counter << std::endl;
  return 0;
}
```

В этом примере:

1. Файл `counter.cpp` определяет внешнюю переменную `global_counter` и функцию `increment_counter()`, которая увеличивает значение этой переменной. 
2. Файл `main.cpp` объявляет внешнюю переменную `global_counter` и функцию `increment_counter()`, чтобы использовать их в своей работе.

При компиляции и сборке проекта линкер соединит определение `global_counter` из `counter.cpp` с объявлением  в `main.cpp`. В результате  оба файла будут работать с одним и тем же объектом в памяти.

### Статические переменные и внешнее связывание

По умолчанию, переменные, объявленные вне функций, имеют **внешнее связывание**.  Однако, можно ограничить область видимости переменной одним файлом с помощью ключевого слова `static`. 

```c++
// file.cpp
static int private_counter = 0; // Видна только внутри файла file.cpp
```

Переменная `private_counter` будет видна только внутри файла `file.cpp` и не будет доступна другим файлам проекта.

### Преимущества и недостатки

Использование внешних объектов имеет свои преимущества и недостатки:

**Преимущества:**

* **Глобальный доступ:** Внешние объекты позволяют организовать общий доступ к данным из различных частей программы.
* **Удобство использования:**  Внешние объекты упрощают передачу данных между функциями и модулями.

**Недостатки:**

* **Нарушение инкапсуляции:**  Чрезмерное использование внешних объектов может привести к созданию кода, который сложно понимать и поддерживать.
* **Проблемы с безопасностью типов:**  Компилятор не всегда может отследить все использования внешнего объекта, что может привести к ошибкам.

### Рекомендации

* Используйте внешние объекты sparingly - только тогда, когда это действительно необходимо.
* Предпочитайте передачу аргументов в функции вместо использования глобальных переменных.
* Для организации глобальных констант используйте  `const` и `extern`.
* Тщательно документируйте использование внешних объектов.

## Заключение

Внешние объекты - мощный инструмент языка C++, который может быть полезен при разработке крупных проектов.  Однако, важно использовать их с осторожностью, чтобы избежать potential problems с безопасностью и удобством поддержки кода.
