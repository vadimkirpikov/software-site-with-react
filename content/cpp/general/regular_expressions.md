## Регулярные выражения в C++

Регулярные выражения - это мощный инструмент для работы с текстом, позволяющий описывать шаблоны (паттерны) и искать вхождения этих шаблонов в строках. С помощью регулярных выражений можно:

* Проверять, соответствует ли строка заданному шаблону.
* Извлекать подстроки из строки, соответствующие шаблону.
* Заменять найденные подстроки на другие.
* Разбивать строку на подстроки по заданному разделителю.

C++ предоставляет библиотеку `<regex>`, которая реализует функционал регулярных выражений. 

### Основные компоненты

Библиотека `<regex>` включает в себя следующие основные компоненты:

* **Класс `std::regex`:** Представляет собой скомпилированное регулярное выражение.
* **Функции поиска:** Используются для поиска вхождений регулярного выражения в строке.
* **Итераторы:** Позволяют перемещаться по найденным вхождениям.
* **Класс `std::match_results`:** Хранит результаты поиска, включая найденные подстроки.

### Создание регулярного выражения

Для создания регулярного выражения в C++ используется класс `std::regex`. Конструктор этого класса принимает строку, содержащую шаблон регулярного выражения.

**Пример:**

```cpp
#include <regex>
#include <string>

int main() {
    // Создание регулярного выражения для поиска email-адреса
    std::regex email_regex(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");

    return 0;
}
```

В этом примере мы создали объект `email_regex`, представляющий собой скомпилированное регулярное выражение для поиска email-адреса. Шаблон `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$` использует следующие элементы:

* `^` - начало строки.
* `[a-zA-Z0-9._%+-]+` - один или более символов из указанного диапазона.
* `@` - символ "@".
* `[a-zA-Z0-9.-]+` - один или более символов из указанного диапазона.
* `\.` - символ ".".
* `[a-zA-Z]{2,}` - от двух и более символов из диапазона a-z и A-Z.
* `$` - конец строки.

### Поиск вхождений

Для поиска вхождений регулярного выражения в строке используются функции `std::regex_search`, `std::regex_match` и `std::regex_replace`.

**Функция `std::regex_search`:**

* Принимает два аргумента: строку для поиска и объект `std::regex`.
* Возвращает `true`, если в строке найдено хотя бы одно вхождение регулярного выражения, и `false` в противном случае.

**Пример:**

```cpp
#include <regex>
#include <string>
#include <iostream>

int main() {
    std::string text = "Мой email-адрес: example@domain.com";
    std::regex email_regex(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");

    if (std::regex_search(text, email_regex)) {
        std::cout << "Email-адрес найден!" << std::endl;
    } else {
        std::cout << "Email-адрес не найден!" << std::endl;
    }

    return 0;
}
```

В этом примере функция `std::regex_search` вернет `true`, так как строка `text` содержит подстроку, соответствующую шаблону регулярного выражения `email_regex`.

**Функция `std::regex_match`:**

* Проверяет, соответствует ли вся строка целиком заданному регулярному выражению.

**Пример:**

```cpp
#include <regex>
#include <string>
#include <iostream>

int main() {
    std::string text = "example@domain.com";
    std::regex email_regex(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");

    if (std::regex_match(text, email_regex)) {
        std::cout << "Строка является email-адресом!" << std::endl;
    } else {
        std::cout << "Строка не является email-адресом!" << std::endl;
    }

    return 0;
}
```

В этом примере функция `std::regex_match` вернет `true`, так как вся строка `text` соответствует шаблону регулярного выражения `email_regex`.

### Извлечение найденных подстрок

Для извлечения найденных подстрок используется класс `std::match_results`. Этот класс хранит результаты поиска, включая найденные подстроки.

**Пример:**

```cpp
#include <regex>
#include <string>
#include <iostream>

int main() {
    std::string text = "Мой email-адрес: example@domain.com";
    std::regex email_regex(R"(([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,}))");
    std::smatch match;

    if (std::regex_search(text, match, email_regex)) {
        std::cout << "Полный email-адрес: " << match.str(0) << std::endl; // Вся найденная подстрока
        std::cout << "Имя пользователя: " << match.str(1) << std::endl;
        std::cout << "Домен: " << match.str(2) << std::endl;
    } else {
        std::cout << "Email-адрес не найден!" << std::endl;
    }

    return 0;
}
```

В этом примере мы использовали скобки в регулярном выражении, чтобы создать подвыражения. Каждое подвыражение заключается в скобки. Метод `str(0)` объекта `match` возвращает всю найденную подстроку, а методы `str(1)` и `str(2)` - подстроки, соответствующие первому и второму подвыражению соответственно.

### Замена подстрок

Для замены найденных подстрок используется функция `std::regex_replace`. 

**Пример:**

```cpp
#include <regex>
#include <string>
#include <iostream>

int main() {
    std::string text = "Мой email-адрес: example@domain.com";
    std::regex email_regex(R"(([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,}))");

    std::string new_text = std::regex_replace(text, email_regex, "***");

    std::cout << "Исходный текст: " << text << std::endl;
    std::cout << "Новый текст: " << new_text << std::endl;

    return 0;
}
```

В этом примере мы заменили все найденные email-адреса на "***".

## Заключение

Библиотека `<regex>` предоставляет мощный функционал для работы с регулярными выражениями в C++. С помощью регулярных выражений можно решать различные задачи, связанные с обработкой текста, такие как валидация данных, парсинг, поиск и замена подстрок.
