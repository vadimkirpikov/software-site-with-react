## Ассоциативные контейнеры: std::map и std::unordered_map

В C++ существует несколько типов контейнеров, предназначенных для хранения и обработки данных. В этой статье мы рассмотрим два важных ассоциативных контейнера: `std::map` и `std::unordered_map`. Оба контейнера позволяют хранить пары "ключ-значение", где каждый ключ уникален и связан с определенным значением. 

### std::map

`std::map` – это отсортированный ассоциативный контейнер, который хранит элементы в виде упорядоченной по ключу древовидной структуры. Это обеспечивает логарифмическую сложность операций поиска, вставки и удаления элементов.

**Объявление:**

```c++
#include <map>

std::map<KeyType, ValueType> myMap;
```

* **KeyType** - тип данных ключа.
* **ValueType** - тип данных значения.

**Основные операции:**

| Операция | Описание | Сложность |
|---|---|---|
| `insert(key, value)` | Вставка пары ключ-значение | Логарифмическая |
| `operator[] (key)`  | Доступ к значению по ключу (создает элемент, если ключ не найден) | Логарифмическая |
| `at(key)` | Доступ к значению по ключу (генерирует исключение, если ключ не найден) | Логарифмическая |
| `find(key)` | Поиск элемента по ключу | Логарифмическая |
| `erase(key)` | Удаление элемента по ключу | Логарифмическая |
| `size()` | Возвращает количество элементов | Постоянная |
| `empty()` | Проверяет, пуст ли контейнер | Постоянная |

**Пример:**

```c++
#include <iostream>
#include <map>
#include <string>

int main() {
  // Создаем словарь, где ключ - строка (имя), 
  // а значение - число (возраст)
  std::map<std::string, int> ages;

  // Добавляем элементы
  ages.insert({"Иван", 25});
  ages["Мария"] = 30; 

  // Выводим размер словаря
  std::cout << "Количество элементов: " << ages.size() << std::endl;

  // Поиск по ключу
  if (ages.find("Иван") != ages.end()) {
    std::cout << "Возраст Ивана: " << ages["Иван"] << std::endl; 
  }

  // Удаление элемента
  ages.erase("Мария");

  // Проверка на пустоту
  if (ages.empty()) {
    std::cout << "Словарь пуст" << std::endl;
  } else {
    std::cout << "Словарь не пуст" << std::endl;
  }

  return 0;
}
```

### std::unordered_map

`std::unordered_map` – это неупорядоченный ассоциативный контейнер, который хранит элементы в виде хэш-таблицы. Хэш-таблица обеспечивает (в среднем случае) постоянную сложность операций поиска, вставки и удаления элементов. Однако в худшем случае сложность может быть линейной.

**Объявление:**

```c++
#include <unordered_map>

std::unordered_map<KeyType, ValueType> myUnorderedMap;
```

* **KeyType** - тип данных ключа.
* **ValueType** - тип данных значения.

**Основные операции:**

`std::unordered_map` поддерживает те же основные операции, что и `std::map`, с той же семантикой, но с другой сложностью:

| Операция | Сложность (в среднем) | Сложность (худший случай) |
|---|---|---|
| `insert(key, value)` | Постоянная | Линейная |
| `operator[] (key)`  | Постоянная | Линейная |
| `at(key)` | Постоянная | Линейная |
| `find(key)` | Постоянная | Линейная |
| `erase(key)` | Постоянная | Линейная |
| `size()` | Постоянная | - |
| `empty()` | Постоянная | - |

**Пример:**

```c++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
  // Создаем словарь, где ключ - строка (название товара),
  // а значение - число (цена)
  std::unordered_map<std::string, double> prices;

  // Добавляем элементы
  prices.insert({"Яблоко", 1.5});
  prices["Банан"] = 0.75;

  // Выводим размер словаря
  std::cout << "Количество элементов: " << prices.size() << std::endl;

  // Поиск по ключу
  if (prices.find("Банан") != prices.end()) {
    std::cout << "Цена банана: " << prices["Банан"] << std::endl;
  }

  return 0;
}
```

### Выбор между std::map и std::unordered_map

Выбор между `std::map` и `std::unordered_map` зависит от требований к производительности и потребления памяти.

**Используйте `std::map`, если:**

* Необходим гарантированный порядок элементов по ключу.
* Важна предсказуемая производительность, даже в худшем случае.

**Используйте `std::unordered_map`, если:**

* Порядок элементов не важен.
* Необходима максимально быстрая скорость доступа к элементам в среднем случае.


Важно помнить, что `std::unordered_map` требует наличия хэш-функции для типа ключа.  

Более подробно о хэш-таблицах и особенностях реализации `std::unordered_map` вы узнаете в следующих разделах руководства. 
