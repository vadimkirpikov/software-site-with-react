## Конструктор перемещения

В C++ мы часто сталкиваемся с ситуациями, когда требуется передача владения ресурсами между объектами. Обычное копирование может быть неэффективным, особенно при работе с тяжелыми ресурсами. Для решения этой проблемы в C++11 были введены семантика перемещения, конструкторы перемещения и операторы перемещающего присваивания.

### Что такое конструктор перемещения?

Конструктор перемещения - это специальный конструктор класса, который принимает ссылку rvalue (обычно обозначается как `&&`) на объект того же класса. В отличие от конструктора копирования, который создает полную копию объекта, конструктор перемещения "крадет" ресурсы у переданного объекта, оставляя его в валидном, но потенциально пустом, состоянии.

### Зачем нужен конструктор перемещения?

Рассмотрим пример класса `String`, хранящего строку в динамически выделенной памяти:

```cpp
class String {
public:
  // Конструктор
  String(const char* str) : data(new char[strlen(str) + 1]) {
    strcpy(data, str);
  }

  // Деструктор
  ~String() {
    delete[] data;
  }

  // Конструктор копирования
  String(const String& other) : data(new char[strlen(other.data) + 1]) {
    strcpy(data, other.data);
  }

  // Оператор присваивания копированием
  String& operator=(const String& other) {
    if (this != &other) {
      delete[] data;
      data = new char[strlen(other.data) + 1];
      strcpy(data, other.data);
    }
    return *this;
  }

private:
  char* data;
};
```

В этом примере, при копировании или присваивании объекта `String` мы выделяем новую память и копируем содержимое строки. Это может быть неэффективно, если мы работаем с большими строками или если производим многократные копирования.

Например:

```cpp
String str1 = "Hello, world!";
String str2 = str1; // Копирование str1 в str2
String str3 = std::move(str1); // Перемещение str1 в str3
```

В этом коде, при создании `str2` происходит копирование строки "Hello, world!". Однако, при создании `str3` мы используем `std::move`, чтобы явно указать, что мы хотим переместить ресурсы из `str1` в `str3`.

### Реализация конструктора перемещения

Для класса `String` конструктор перемещения может выглядеть следующим образом:

```cpp
// Конструктор перемещения
String(String&& other) noexcept : data(other.data) {
  other.data = nullptr;
}
```

В этом конструкторе мы просто копируем указатель `data` из переданного объекта в наш объект, а затем устанавливаем `data` в переданном объекте в `nullptr`. Таким образом, мы избегаем копирования данных и просто "крадем" ресурсы у переданного объекта.

### noexcept

Ключевое слово `noexcept` указывает, что конструктор перемещения не генерирует исключений. Это важно, так как позволяет компилятору оптимизировать код и использовать семантику перемещения в большем количестве случаев.

### Преимущества использования конструкторов перемещения

* **Повышение производительности:** Избегаем ненужного копирования данных, особенно при работе с тяжелыми ресурсами.
* **Улучшение семантики кода:** Явно указываем, когда требуется передача владения ресурсами.
* **Возможность работы с некопируемыми ресурсами:** Некоторые ресурсы, например, потоки ввода/вывода, не могут быть скопированы. С помощью конструкторов перемещения мы можем передавать владение такими ресурсами.

### Когда нужно определять конструктор перемещения?

Обычно, если вы определили деструктор, конструктор копирования или оператор присваивания копированием, вам также следует определить конструктор перемещения и оператор перемещающего присваивания. Это обеспечит эффективную и безопасную работу с вашим классом.

### Пример использования конструктора перемещения

```cpp
#include <iostream>

class String {
public:
  // ... (предыдущие объявления)

  // Конструктор перемещения
  String(String&& other) noexcept : data(other.data) {
    std::cout << "Move constructor called.\n";
    other.data = nullptr;
  }

  // Оператор перемещающего присваивания
  String& operator=(String&& other) noexcept {
    if (this != &other) {
      delete[] data;
      data = other.data;
      other.data = nullptr;
    }
    std::cout << "Move assignment operator called.\n";
    return *this;
  }
};

int main() {
  String str1 = "Hello, world!";
  String str2 = std::move(str1); // Вызов конструктора перемещения
  String str3;
  str3 = std::move(str2); // Вызов оператора перемещающего присваивания

  return 0;
}
```

В этом примере мы добавили конструктор перемещения и оператор перемещающего присваивания к классу `String`. При запуске программы, вы увидите, что конструктор перемещения и оператор перемещающего присваивания вызываются, что говорит о том, что ресурсы перемещаются, а не копируются.
