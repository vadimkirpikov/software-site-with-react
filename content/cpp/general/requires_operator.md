## Оператор requires

В C++20 был введен оператор `requires`, который значительно упрощает проверку концептов и ограничений шаблонов. 

До появления `requires` проверка ограничений шаблонов была громоздкой и требовала сложных конструкций с использованием `std::enable_if` и специализации шаблонов. Оператор `requires` предлагает более лаконичный и выразительный синтаксис для определения требований к типам и значениям, используемым в шаблонах.

### Синтаксис и использование

Основной синтаксис оператора `requires` выглядит следующим образом:

```cpp
template <typename T>
requires Constraint<T> // Проверка ограничения Constraint<T>
void func(T value) {
  // ...
}
```

Здесь `Constraint<T>` - это выражение, которое проверяет, удовлетворяет ли тип `T` определенному ограничению. 

Рассмотрим простой пример, где функция принимает только типы, поддерживающие оператор сложения:

```cpp
template <typename T>
requires requires(T a, T b) {
  a + b; // Проверка наличия оператора сложения для типа T
}
void add(T a, T b) {
  std::cout << a + b << std::endl;
}

int main() {
  add(1, 2);    // OK: int поддерживает оператор сложения
  add(1.5, 2.5); // OK: double поддерживает оператор сложения
  // add("hello", "world"); // Ошибка компиляции: string не поддерживает оператор сложения
}
```

В этом примере `requires` проверяет, возможно ли выполнить выражение `a + b` для типа `T`. Если да, то ограничение выполнено, и функция может быть использована с этим типом.

### Формы выражений в блоке requires

Внутри блока `requires` можно использовать различные формы выражений для проверки ограничений:

* **Простые выражения:**  
  Как в примере выше, можно использовать любое выражение, допустимое в C++. Компилятор проверит, компилируется ли это выражение для заданного типа `T`.

* **Выражения с `typeid`:** 
  Можно использовать `typeid(T)` для проверки типа `T` на соответствие конкретному типу или на наличе определенных методов.

  ```cpp
  template<typename T>
  requires requires {
    typeid(T) == typeid(int); // Проверка, что T - это int
  }
  void func(T value) {
    // ...
  }
  ```

* **Выражения с `noexcept`:** 
  Можно проверить, является ли вызов функции или оператора для типа `T` свободным от исключений.

  ```cpp
  template<typename T>
  requires requires(T a) {
    noexcept(a++); // Проверка, что инкремент T не выбрасывает исключения
  }
  void func(T value) {
    // ...
  }
  ```

### Преимущества использования requires

Использование оператора `requires` для проверки концептов и ограничений шаблонов дает ряд преимуществ:

* **Улучшенная читаемость кода:**  
  Код становится более лаконичным и понятным, так как ограничения явно определены с помощью `requires`.

* **Более информативные сообщения об ошибках:**
  Если ограничение не выполнено, компилятор выдаст более понятное сообщение об ошибке, указав на конкретное ограничение, которое не удалось выполнить.

* **Упрощение отладки:** 
  Использование `requires` упрощает отладку кода, так как ошибки, связанные с несоответствием типов, будут обнаружены на этапе компиляции.

### Заключение

Оператор `requires` является мощным инструментом для работы с концептами и ограничениями шаблонов в C++20. Он позволяет писать более выразительный, читаемый и безопасный код, упрощая разработку и поддержку шаблонных библиотек и приложений.
