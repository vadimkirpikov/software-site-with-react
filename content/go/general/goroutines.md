## Горутины: параллелизм в Golang

Одним из ключевых преимуществ Golang является его встроенная поддержка параллелизма. В основе этой поддержки лежат горутины - легковесные потоки исполнения, управляемые планировщиком Go. В отличие от традиционных потоков операционной системы, горутины потребляют меньше ресурсов и переключаются эффективнее. 

### Создание и запуск горутин

Для запуска функции в качестве горутины достаточно поставить ключевое слово `go` перед ее вызовом. 

```go
package main

import (
	"fmt"
	"time"
)

func printNumbers() {
	for i := 1; i <= 5; i++ {
		fmt.Println("Горутина:", i)
		time.Sleep(time.Millisecond * 500) // имитация работы
	}
}

func main() {
	go printNumbers() // запуск функции как горутины

	fmt.Println("Основная горутина запущена")
	time.Sleep(time.Second * 3) // даем время горутинам завершиться
	fmt.Println("Основная горутина завершена")
}
```

В данном примере функция `printNumbers()` запускается как горутина. Одновременно с ее работой, основная горутина (функция `main()`) продолжает свое выполнение. 

### Синхронизация горутин

Зачастую горутинам требуется взаимодействовать друг с другом или с основной программой. Для этого Golang предоставляет механизмы синхронизации.

#### Ожидание завершения с помощью `WaitGroup`

`WaitGroup` позволяет основной горутине дождаться завершения заданного количества горутин.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done() // уменьшаем счетчик при завершении горутины

	fmt.Printf("Рабочий %d начал работу\n", id)
	time.Sleep(time.Second)
	fmt.Printf("Рабочий %d завершил работу\n", id)
}

func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		wg.Add(1)      // увеличиваем счетчик для каждой горутины
		go worker(i, &wg) // передаем wg по ссылке
	}

	wg.Wait() // ждем завершения всех горутин
	fmt.Println("Все рабочие завершили работу")
}
```

В этом примере `WaitGroup` отслеживает количество запущенных горутин (`wg.Add(1)`) и ожидает их завершения (`wg.Wait()`). Каждая горутина, завершая работу, уменьшает счетчик (`wg.Done()`).

#### Каналы для обмена данными

Каналы позволяют безопасно обмениваться данными между горутинами.

```go
package main

import (
	"fmt"
)

func sender(ch chan<- string) {
	messages := []string{"Привет", "из", "горутины"}
	for _, msg := range messages {
		ch <- msg
	}
	close(ch) // закрываем канал после отправки всех сообщений
}

func receiver(ch <-chan string) {
	for msg := range ch {
		fmt.Println("Получено сообщение:", msg)
	}
}

func main() {
	messagesCh := make(chan string) // создаем канал строк

	go sender(messagesCh)
	receiver(messagesCh)
}
```

В этом примере горутина `sender()` отправляет сообщения в канал, а горутина `receiver()` принимает и обрабатывает их. Закрытие канала (`close(ch)`) сигнализирует о завершении отправки данных.

### Заключение

Горутины - мощный инструмент для написания параллельного кода в Golang. Используя механизмы синхронизации, такие как `WaitGroup` и каналы, можно создавать эффективные и безопасные многопоточные приложения. 
