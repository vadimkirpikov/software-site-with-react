<h2>Методы указателей</h2>

В Go, как и во многих других языках программирования, функции могут получать аргументы. Методы в этом плане ничем не отличаются: они также могут принимать аргументы, которые называются **ресиверами**.  Ресиверы позволяют методам получать доступ к данным структуры, с которой они связаны, и модифицировать их.

Существует два типа методов: методы значений и методы указателей.  Методы значений получают копию значения структуры в качестве ресивера, в то время как методы указателей получают указатель на структуру.

<h3>Методы значений</h3>

Когда вы определяете метод с ресивером-значением, Go создает копию значения структуры и передает ее методу.  Это означает, что любые изменения, внесенные в ресивер внутри метода, не повлияют на исходную структуру.

Рассмотрим пример:

```go
package main

import "fmt"

type Book struct {
	Title string
	Author string
}

// Метод UpdateTitle принимает копию структуры Book
func (b Book) UpdateTitle(newTitle string) {
	b.Title = newTitle
}

func main() {
	book := Book{"Война и мир", "Лев Толстой"}

	// Вызываем метод UpdateTitle
	book.UpdateTitle("Анна Каренина")

	// Выводим информацию о книге
	fmt.Println(book.Title) // Выведет "Война и мир"
}
```

В этом примере мы определили метод `UpdateTitle`, который принимает строку `newTitle` и обновляет поле `Title` структуры `Book`. Однако, поскольку `UpdateTitle` является методом значения, он получает копию структуры `book`, а не саму структуру.  Поэтому, когда мы вызываем `book.UpdateTitle("Анна Каренина")`, изменения применяются только к копии, а исходная структура `book` остается неизменной.

<h3>Методы указателей</h3>

Методы указателей, в отличие от методов значений, получают указатель на структуру в качестве ресивера. Это позволяет им напрямую изменять значения полей структуры.

Давайте изменим предыдущий пример и используем метод указателя:

```go
package main

import "fmt"

type Book struct {
	Title string
	Author string
}

// Метод UpdateTitle принимает указатель на структуру Book
func (b *Book) UpdateTitle(newTitle string) {
	b.Title = newTitle
}

func main() {
	book := Book{"Война и мир", "Лев Толстой"}

	// Вызываем метод UpdateTitle
	(&book).UpdateTitle("Анна Каренина")

	// Выводим информацию о книге
	fmt.Println(book.Title) // Выведет "Анна Каренина"
}
```

Единственное отличие этого кода от предыдущего заключается в объявлении метода `UpdateTitle`:

```go
func (b *Book) UpdateTitle(newTitle string) {
	b.Title = newTitle
}
```

Теперь метод `UpdateTitle` принимает указатель на `Book` ( `*Book` ) в качестве ресивера. Это означает, что любые изменения, внесенные в ресивер `b` внутри метода, будут напрямую отражаться на исходной структуре `book`.

Также обратите внимание на то, как мы вызываем метод `UpdateTitle`:

```go
(&book).UpdateTitle("Анна Каренина")
```

Здесь мы используем оператор `&`, чтобы получить указатель на `book` перед вызовом метода. 

<h3>Когда использовать методы указателей</h3>

Есть два основных случая, когда вам следует использовать методы указателей:

1. **Когда вам нужно изменить значение ресивера внутри метода.**  Как мы видели в предыдущем примере, методы значений получают копию структуры, поэтому изменения, внесенные внутри метода, не повлияют на исходную структуру. Методы указателей, с другой стороны, получают указатель на структуру, что позволяет им изменять ее напрямую.

2. **Когда вам нужно избежать копирования больших структур.**  Если ваша структура большая, то передача ее копии в метод может быть неэффективной с точки зрения производительности. В этом случае лучше использовать метод указателя, который будет работать с исходной структурой, а не с ее копией.

В остальных случаях можно использовать методы значений. 
