## defer и panic в Golang

В Golang механизмы `defer` и `panic` предоставляют мощные инструменты для управления выполнением программы и обработки ошибок.

### defer

Оператор `defer` используется для отложенного вызова функции. Вызов отложенной функции происходит после выхода из окружающей функции, независимо от того, как произошел выход (нормальное завершение, ошибка или `panic`).

**Синтаксис:**

```go
defer функция()
```

**Пример:**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	f, err := os.Create("defer.txt") // Открываем файл
	if err != nil {
		fmt.Println("Ошибка при открытии файла:", err)
		return 
	}
	defer f.Close() // Отложенное закрытие файла

	fmt.Fprintln(f, "Привет из defer!") // Записываем в файл
}
```

В этом примере функция `f.Close()` вызывается после завершения функции `main()`, гарантируя закрытие файла. 

**Несколько defer:**

Внутри одной функции можно использовать несколько `defer`.  Они будут выполнены в порядке **LIFO** (Last-In-First-Out).

```go
package main

import "fmt"

func main() {
	fmt.Println("Начало")
	defer fmt.Println("defer 3")
	defer fmt.Println("defer 2")
	defer fmt.Println("defer 1")
	fmt.Println("Конец")
}
```

Вывод:

```
Начало
Конец
defer 1
defer 2
defer 3
```

**defer и параметры:**

Аргументы для `defer` вычисляются сразу, а не во время вызова:

```go
package main

import "fmt"

func main() {
	i := 1

	defer fmt.Println("defer:", i) // i = 1

	i++
	fmt.Println("i:", i) // i = 2
}
```

Вывод:

```
i: 2
defer: 1
```

### panic

Механизм `panic` используется для сигнализации о критической ошибке, которая не может быть обработана штатно. `Panic` прерывает нормальное выполнение программы, вызывает все отложенные функции (`defer`) в текущей функции и всех ее родительских функциях, а затем завершает программу.

**Синтаксис:**

```go
panic(значение)
```

`Значение` может быть любого типа и используется для передачи информации об ошибке.

**Пример:**

```go
package main

import "fmt"

func main() {
	fmt.Println("Начало")
	panic("Что-то пошло не так!")
	fmt.Println("Этот код не выполнится")
}
```

Вывод:

```
Начало
panic: Что-то пошло не так!
```

### recover

Для перехвата `panic` и предотвращения аварийного завершения программы используется функция `recover`. `Recover`  возвращает значение, переданное в `panic`,  и останавливает "раскрутку" стека вызовов.  Важно помнить, что `recover` работает только внутри отложенных функций (`defer`).

**Пример:**

```go
package main

import "fmt"

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Panic перехвачен:", r)
		}
	}()

	panic("Что-то пошло не так!")
}
```

Вывод:

```
Panic перехвачен: Что-то пошло не так!
```

### Использование defer и panic

`Defer` и `panic` - это мощные инструменты, которые нужно использовать с осторожностью. `Defer` отлично подходит для гарантированного освобождения ресурсов, таких как файлы и сетевые подключения. `Panic` следует использовать только в случаях действительно критических ошибок, которые невозможно обработать иначе. 

**Примеры использования:**

* **Закрытие файлов и подключений:** 
    ```go
    defer file.Close()
    defer conn.Close()
    ```

* **Освобождение мьютексов:** 
    ```go
    mu.Lock()
    defer mu.Unlock()
    ```

* **Обработка паники в горутинах:** 
    ```go
    go func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Println("Panic в горутине:", r)
            }
        }()
        // Код, который может вызвать panic
    }()
    ```

**Важно:** 
* `Recover` возвращает `nil`, если `panic` не происходил. 
* `Panic` не следует использовать для обработки обычных ошибок.
* Чрезмерное использование `panic` может сделать код трудным для понимания и поддержки.


