## Синхронизация в Golang

В мире параллельного программирования синхронизация играет ключевую роль, обеспечивая корректную и предсказуемую работу кода, выполняемого в нескольких горутинах. Golang предоставляет мощные и гибкие инструменты для управления синхронизацией, такие как горутины, каналы и пакет `sync`.

### Горутины

Горутины - легковесные потоки выполнения, которые позволяют запускать функции конкурентно. Создание горутины осуществляется при помощи ключевого слова `go` перед вызовом функции.

```go
package main

import (
	"fmt"
	"time"
)

func printNumbers() {
	for i := 1; i <= 5; i++ {
		fmt.Println("Число:", i)
		time.Sleep(time.Millisecond * 500)
	}
}

func main() {
	go printNumbers() // Запускаем функцию как горутину
	
	time.Sleep(time.Second * 3) 
	fmt.Println("Главная горутина завершена")
}
```

В этом примере функция `printNumbers` запускается как горутина.  Обратите внимание, что главная горутина `main` завершается раньше, чем  `printNumbers` успевает вывести все числа. Для синхронизации выполнения горутин используются каналы.

### Каналы

Каналы являются механизмом обмена данными и синхронизации между горутинами. Они представляют собой типизированные очереди, по которым горутины могут отправлять и получать данные.

```go
package main

import (
	"fmt"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Println("Рабочий", id, "обрабатывает задание", j)
		results <- j * 2
	}
}

func main() {
	jobs := make(chan int, 100)
	results := make(chan int, 100)

	// Запускаем 3 рабочих горутины
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// Отправляем 5 заданий в канал jobs
	for j := 1; j <= 5; j++ {
		jobs <- j
	}
	close(jobs) // Закрываем канал jobs, сигнализируя об окончании заданий

	// Получаем результаты из канала results
	for a := 1; a <= 5; a++ {
		fmt.Println("Результат:", <-results)
	}
}
```

В этом примере создаются два канала: `jobs` для передачи заданий и `results` для получения результатов. Три рабочих горутины `worker` запускаются с передачей им каналов.  Главная горутина отправляет задания в канал `jobs`, а затем ожидает результаты в канале `results`. 

### Пакет sync

Пакет `sync` предоставляет дополнительные инструменты для синхронизации, такие как мьютексы (`sync.Mutex`) и условные переменные (`sync.Cond`).

#### Мьютексы

Мьютексы используются для защиты разделяемых ресурсов от одновременного доступа из нескольких горутин. Мьютекс может находиться в одном из двух состояний: заблокирован или разблокирован.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type Counter struct {
	mu    sync.Mutex
	value int
}

func (c *Counter) Increment() {
	c.mu.Lock()         // Блокируем мьютекс
	defer c.mu.Unlock() // Отложенная разблокировка мьютекса

	c.value++
	time.Sleep(time.Millisecond * 500) // Имитация работы
	fmt.Println("Значение счетчика:", c.value)
}

func main() {
	counter := &Counter{}

	for i := 0; i < 5; i++ {
		go counter.Increment()
	}

	time.Sleep(time.Second * 3)
}
```

В этом примере мьютекс `mu` используется для защиты доступа к полю `value` структуры `Counter`. Функция `Increment` блокирует мьютекс перед увеличением значения счетчика, гарантируя, что только одна горутина может изменять его одновременно. 

#### Условные переменные

Условные переменные используются для ожидания наступления определенного условия, сигнализируя горутины при его наступлении.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(1)

	var cond = sync.NewCond(&sync.Mutex{})
	var ready bool

	go func() {
		defer wg.Done()
		cond.L.Lock()
		for !ready {
			cond.Wait() // Ожидание сигнала
		}
		cond.L.Unlock()
		fmt.Println("Условие выполнено!")
	}()

	time.Sleep(time.Second * 2)
	cond.L.Lock()
	ready = true
	cond.L.Unlock()
	cond.Signal() // Отправка сигнала

	wg.Wait()
}
```

В этом примере горутина ожидает, пока переменная `ready` не станет истинной. Функция `cond.Wait()` приостанавливает выполнение горутины до тех пор, пока не будет получен сигнал от `cond.Signal()`. 

Это лишь базовые примеры использования инструментов синхронизации в Golang. Для более глубокого понимания и применения  рекомендуется обратиться к официальной документации языка.
