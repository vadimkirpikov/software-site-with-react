## Стандартные потоки ввода-вывода и io.Copy

В программировании часто возникает необходимость взаимодействия с внешним миром: считывания данных из файла, получения ввода от пользователя, вывода информации на экран. Для этих целей в Go, как и во многих других языках программирования, существуют стандартные потоки ввода-вывода.

### Стандартные потоки

Go предоставляет три стандартных потока:

| Поток    | Описание                                                                 |
|----------|--------------------------------------------------------------------------|
| Stdin   | Стандартный поток ввода, используется для получения данных от пользователя. |
| Stdout  | Стандартный поток вывода, используется для вывода данных на экран.      |
| Stderr  | Стандартный поток ошибок, используется для вывода сообщений об ошибках. |

Эти потоки представлены в пакете `os` типами `*os.File`.

**Пример:**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// Запись строки в стандартный поток вывода
	fmt.Println("Привет, мир!")

	// Чтение строки из стандартного потока ввода
	var input string
	fmt.Print("Введите строку: ")
	fmt.Scanln(&input)

	// Вывод считанной строки в стандартный поток вывода
	fmt.Println("Вы ввели:", input)

	// Запись сообщения об ошибке в стандартный поток ошибок
	fmt.Fprintln(os.Stderr, "Произошла ошибка!")
}
```

В этом примере мы используем функции пакета `fmt` для работы со стандартными потоками. 
* `fmt.Println` записывает строку в `Stdout`, добавляя перевод строки.
* `fmt.Print` записывает строку в `Stdout` без перевода строки.
* `fmt.Scanln` считывает строку из `Stdin`, завершая чтение при нажатии Enter.
* `fmt.Fprintln` записывает строку в указанный поток, в данном случае `Stderr`, добавляя перевод строки.

### Пакет io и функция io.Copy

Пакет `io` предоставляет набор функций для работы с потоками данных в Go. Одна из самых полезных функций этого пакета - `io.Copy`, которая копирует данные из одного потока в другой.

**Пример:**

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	// Открываем файл для чтения
	file, err := os.Open("input.txt")
	if err != nil {
		fmt.Println("Ошибка при открытии файла:", err)
		return
	}
	defer file.Close() // Закрываем файл после завершения работы

	// Копируем данные из файла в стандартный поток вывода
	_, err = io.Copy(os.Stdout, file)
	if err != nil {
		fmt.Println("Ошибка при копировании:", err)
		return
	}
}
```

В этом примере мы открываем файл `input.txt` для чтения и копируем его содержимое в стандартный поток вывода с помощью `io.Copy`. 

**Пошаговое объяснение:**

1. `os.Open("input.txt")` открывает файл с именем `input.txt` для чтения и возвращает объект `*os.File` и ошибку, если таковая возникла.
2. `defer file.Close()` откладывает закрытие файла до момента завершения функции `main`.
3. `io.Copy(os.Stdout, file)` копирует данные из объекта `file`, представляющего открытый файл, в объект `os.Stdout`, представляющий стандартный поток вывода. Функция `io.Copy` возвращает количество скопированных байт и ошибку, если таковая возникла.
4. Блок `if err != nil` проверяет наличие ошибок на каждом этапе работы с файлом и выводит сообщение об ошибке в стандартный поток ошибок в случае их возникновения.

Функция `io.Copy` - мощный инструмент, который можно использовать для решения широкого круга задач, связанных с обработкой потоков данных. 

**Пример:**

```go
package main

import (
	"io"
	"os"
	"strings"
)

func main() {
	// Создаем новый поток для записи
	reader := strings.NewReader("Это текст для записи в файл")

	// Открываем файл для записи
	file, err := os.Create("output.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// Копируем данные из потока reader в файл
	_, err = io.Copy(file, reader)
	if err != nil {
		panic(err)
	}

	fmt.Println("Данные успешно записаны в файл output.txt")
}
```

В этом примере мы создаем новый поток `reader` с помощью `strings.NewReader` и записываем данные из этого потока в файл `output.txt` с помощью `io.Copy`.
