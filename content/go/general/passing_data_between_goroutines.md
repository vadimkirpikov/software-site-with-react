## Передача потоков данных

Golang предоставляет мощные инструменты для работы с потоками данных — каналами (channels). Каналы позволяют безопасно и эффективно передавать данные между одновременно выполняемыми частями программы (горутинами).

### Основы каналов

Канал — это типизированный конвейер, по которому можно отправлять и получать данные. 

**Объявление канала:**

```go
channelName := make(chan dataType)
```

* `channelName` - имя канала
* `dataType` - тип данных, которые будут передаваться по каналу

**Пример:**

```go
numbers := make(chan int) // Объявление канала для передачи целых чисел
```

**Отправка данных в канал:**

```go
channelName <- value
```

* `channelName` - имя канала
* `value` - значение, отправляемое в канал

**Получение данных из канала:**

```go
value := <- channelName
```

* `value` - переменная, в которую будет записано значение из канала
* `channelName` - имя канала

**Пример:**

```go
package main

import "fmt"

func main() {
    messages := make(chan string)

    go func() { 
        messages <- "Привет из горутины!" 
    }()

    message := <-messages
    fmt.Println(message)
}
```

В этом примере создается канал `messages` для строк. Анонимная горутина отправляет строку "Привет из горутины!" в канал, а функция `main` ожидает получения данных из канала и выводит их на экран.

### Буферизованные и небуферизованные каналы

По умолчанию каналы являются небуферизованными. Это означает, что отправка и получение данных происходят одновременно. Отправляющая горутина блокируется до тех пор, пока принимающая горутина не будет готова принять данные.

**Пример:**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    c := make(chan string)

    go func() {
        time.Sleep(2 * time.Second) // Имитация задержки
        c <- "Сообщение из горутины"
    }()

    fmt.Println(<-c) // Блокировка до получения данных
}
```

В этом примере функция `main` блокируется на строке `fmt.Println(<-c)`, ожидая данные из канала. Отправляющая горутина отправляет сообщение с задержкой в 2 секунды.

**Буферизованные каналы**

Буферизованный канал имеет определенную емкость.  Отправляющая горутина блокируется только тогда, когда буфер полон. Аналогично, принимающая горутина блокируется только при попытке считать данные из пустого буфера.

**Объявление буферизованного канала:**

```go
channelName := make(chan dataType, bufferSize)
```

* `bufferSize` - размер буфера

**Пример:**

```go
package main

import "fmt"

func main() {
    c := make(chan int, 2) // Буфер на 2 элемента

    c <- 1
    c <- 2
    fmt.Println(<-c)
    fmt.Println(<-c)
}
```

### Закрытие каналов

Каналы можно закрыть, чтобы сигнализировать о завершении передачи данных.

```go
close(channelName)
```

**Пример:**

```go
package main

import "fmt"

func main() {
    c := make(chan int, 3)
    c <- 1
    c <- 2
    close(c)

    for num := range c {
        fmt.Println(num)
    }
}
```

В этом примере канал закрывается после отправки двух значений. Цикл `for...range` используется для итерации по каналу и завершается, когда канал закрыт.

### Использование каналов для синхронизации

Каналы можно использовать для синхронизации работы горутин.

**Пример:**

```go
package main

import (
    "fmt"
    "time"
)

func worker(done chan bool) {
    fmt.Println("Работа...")
    time.Sleep(time.Second)
    fmt.Println("Работа завершена")

    done <- true
}

func main() {
    done := make(chan bool, 1)
    go worker(done)

    <-done // Ожидание сигнала от горутины
    fmt.Println("Все горутины завершены")
}
```

В этом примере горутина `worker` отправляет сигнал по каналу `done` после завершения работы. Функция `main` ожидает этот сигнал перед выводом сообщения "Все горутины завершены".

Каналы — это важный инструмент для написания конкурентных программ на Golang. Они позволяют безопасно и эффективно обмениваться данными между горутинами, синхронизировать их работу и создавать элегантные и эффективные решения.
